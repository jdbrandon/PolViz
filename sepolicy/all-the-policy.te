#####################################
# Common groupings of object classes.
#














#####################################
# Common groupings of permissions.
#




















#####################################
# Common socket permission sets.




# socket ioctls allowed to unprivileged apps

########################################
#
# gen_cats(N)
#
# declares categores c0 to c(N-1)
#




########################################
#
# gen_sens(N)
#
# declares sensitivites s0 to s(N-1) with dominance
# in increasing numeric order with s0 lowest, s(N-1) highest
#






########################################
#
# gen_levels(N,M)
#
# levels from s0 to (N-1) with categories c0 to (M-1)
#




########################################
#
# Basic level names for system low and high
#


#
# Common neverallow permissions




#####################################
# domain_trans(olddomain, type, newdomain)
# Allow a transition from olddomain to newdomain
# upon executing a file labeled with type.
# This only allows the transition; it does not
# cause it to occur automatically - use domain_auto_trans
# if that is what you want.
#


#####################################
# domain_auto_trans(olddomain, type, newdomain)
# Automatically transition from olddomain to newdomain
# upon executing a file labeled with type.
#


#####################################
# file_type_trans(domain, dir_type, file_type)
# Allow domain to create a file labeled file_type in a
# directory labeled dir_type.
# This only allows the transition; it does not
# cause it to occur automatically - use file_type_auto_trans
# if that is what you want.
#


#####################################
# file_type_auto_trans(domain, dir_type, file_type)
# Automatically label new files with file_type when
# they are created by domain in directories labeled dir_type.
#


#####################################
# r_dir_file(domain, type)
# Allow the specified domain to read directories, files
# and symbolic links of the specified type.


#####################################
# tmpfs_domain(domain)
# Define and allow access to a unique type for
# this domain when creating tmpfs / shmem / ashmem files.


#####################################
# init_daemon_domain(domain)
# Set up a transition from init to the daemon domain
# upon executing its binary.


#####################################
# app_domain(domain)
# Allow a base set of permissions required for all apps.


#####################################
# net_domain(domain)
# Allow a base set of permissions required for network access.


#####################################
# bluetooth_domain(domain)
# Allow a base set of permissions required for bluetooth access.


#####################################
# unix_socket_connect(clientdomain, socket, serverdomain)
# Allow a local socket connection from clientdomain via
# socket to serverdomain.
#
# Note: If you see denial records that distill to the
# following allow rules:
# allow clientdomain property_socket:sock_file write;
# allow clientdomain init:unix_stream_socket connectto;
# allow clientdomain something_prop:property_service set;
#
# This sequence is indicative of attempting to set a property.
# use set_prop(sourcedomain, targetproperty)
#




#####################################
# set_prop(sourcedomain, targetproperty)
# Allows source domain to set the
# targetproperty.
#


#####################################
# unix_socket_send(clientdomain, socket, serverdomain)
# Allow a local socket send from clientdomain via
# socket to serverdomain.


#####################################
# binder_use(domain)
# Allow domain to use Binder IPC.


#####################################
# binder_call(clientdomain, serverdomain)
# Allow clientdomain to perform binder IPC to serverdomain.


#####################################
# binder_service(domain)
# Mark a domain as being a Binder service domain.
# Used to allow binder IPC to the various system services.


#####################################
# wakelock_use(domain)
# Allow domain to manage wake locks


#####################################
# selinux_check_access(domain)
# Allow domain to check SELinux permissions via selinuxfs.


#####################################
# selinux_check_context(domain)
# Allow domain to check SELinux contexts via selinuxfs.


#####################################
# selinux_setenforce(domain)
# Allow domain to set SELinux to enforcing.


#####################################
# selinux_setbool(domain)
# Allow domain to set SELinux booleans.


#####################################
# security_access_policy(domain)
# Read only access to all policy files and
# selinuxfs


#####################################
# mmac_manage_policy(domain)
# Ability to manage mmac policy files,
# trigger runtime reload, change
# mmac enforcing mode and access logcat.


#####################################
# access_kmsg(domain)
# Ability to read from kernel logs
# and execute the klogctl syscall
# in a non destructive manner. See
# man 2 klogctl


#####################################
# create_pty(domain)
# Allow domain to create and use a pty, isolated from any other domain ptys.


#####################################
# Non system_app application set
#


#####################################
# Recovery only
# SELinux rules which apply only to recovery mode
#


#####################################
# Userdebug or eng builds
# SELinux rules which apply only to userdebug or eng builds
#



#####################################
# write_logd(domain)
# Ability to write to android log
# daemon via sockets


#####################################
# read_logd(domain)
# Ability to run logcat and read from android
# log daemon via sockets


#####################################
# control_logd(domain)
# Ability to control
# android log daemon via sockets


#####################################
# use_keystore(domain)
# Ability to use keystore.
# Keystore is requires the following permissions
# to call getpidcon.


###########################################
# use_drmservice(domain)
# Ability to use DrmService which requires
# DrmService to call getpidcon.


##########################################
# print a message with a trailing newline
# print(`args')

# adbd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type adbd, domain, mlstrustedsubject;




# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow adbd shell_exec:file { getattr open read execute };
allow adbd shell:process transition;
# New domain is entered by executing the file.
allow shell shell_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow shell adbd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit adbd shell:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow adbd shell:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition adbd shell_exec:process shell;


# Do not sanitize the environment or open fds of the shell. Allow signaling
# created processes.
allow adbd shell:process { noatsecure signal };

# Set UID and GID to shell.  Set supplementary groups.
allow adbd self:capability { setuid setgid };

# Drop capabilities from bounding set on user builds.
allow adbd self:capability setpcap;

# Create and use network sockets.

typeattribute adbd netdomain;


# Access /dev/android_adb or /dev/usb-ffs/adb/ep0
allow adbd adb_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow adbd functionfs:dir search;
allow adbd functionfs:file { { getattr open read ioctl lock } { open append write } };

# Use a pseudo tty.
allow adbd devpts:chr_file { { getattr open read ioctl lock } { open append write } };

# adb push/pull /data/local/tmp.
allow adbd shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow adbd shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# adb push/pull sdcard.
allow adbd sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow adbd sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# adb pull /data/anr/traces.txt
allow adbd anr_data_file:dir { open getattr read search ioctl };
allow adbd anr_data_file:file { getattr open read ioctl lock };

# Set service.adb.*, sys.powerctl, and sys.usb.ffs.ready properties.


allow adbd property_socket:sock_file write;
allow adbd init:unix_stream_socket connectto;

allow adbd shell_prop:property_service set;



allow adbd property_socket:sock_file write;
allow adbd init:unix_stream_socket connectto;

allow adbd powerctl_prop:property_service set;



allow adbd property_socket:sock_file write;
allow adbd init:unix_stream_socket connectto;

allow adbd ffs_prop:property_service set;


# Run /system/bin/bu
allow adbd system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# XXX Run toolbox.  Might not be needed.
allow adbd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow adbd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Perform binder IPC to surfaceflinger (screencap)
# XXX Run screencap in a separate domain?

# Call the servicemanager and transfer references to it.
allow adbd servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager adbd:dir search;
allow servicemanager adbd:file { read open };
allow servicemanager adbd:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow adbd surfaceflinger:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow surfaceflinger adbd:binder transfer;
# Receive and use open files from the server.
allow adbd surfaceflinger:fd use;

# b/13188914
allow adbd gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read /data/misc/adb/adb_keys.
allow adbd adb_keys_file:dir search;
allow adbd adb_keys_file:file { getattr open read ioctl lock };



# ndk-gdb invokes adb forward to forward the gdbserver socket.
allow adbd app_data_file:dir search;
allow adbd app_data_file:sock_file write;
allow adbd appdomain:unix_stream_socket connectto;

# ndk-gdb invokes adb pull of app_process, linker, and libc.so.
allow adbd zygote_exec:file { getattr open read ioctl lock };
allow adbd system_file:file { getattr open read ioctl lock };

allow adbd kernel:security read_policy;

allow adbd surfaceflinger_service:service_manager find;
allow adbd bootchart_data_file:dir search;
allow adbd bootchart_data_file:file { getattr open read ioctl lock };

# Allow access to external storage; we have several visible mount points under /storage
# and symlinks to primary storage at places like /storage/sdcard0 and /mnt/user/0/primary
allow adbd storage_file:dir { open getattr read search ioctl };
allow adbd storage_file:lnk_file { getattr open read ioctl lock };
allow adbd mnt_user_file:dir { open getattr read search ioctl };
allow adbd mnt_user_file:lnk_file { getattr open read ioctl lock };
###
### Domain for all zygote spawned apps
###
### This file is the base policy for all zygote spawned apps.
### Other policy files, such as isolated_app.te, untrusted_app.te, etc
### extend from this policy. Only policies which should apply to ALL
### zygote spawned apps should be added here.
###

# WebView and other application-specific JIT compilers
allow appdomain self:process execmem;

allow appdomain ashmem_device:chr_file execute;

# Receive and use open file descriptors inherited from zygote.
allow appdomain zygote:fd use;

# gdbserver for ndk-gdb reads the zygote.
# valgrind needs mmap exec for zygote
allow appdomain zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Read system properties managed by zygote.
allow appdomain zygote_tmpfs:file read;

# Notify zygote of death;
allow appdomain zygote:process sigchld;

# Notify zygote of the wrapped process PID when using --invoke-with.


# Notify shell and adbd of death when spawned via runas for ndk-gdb.
allow appdomain shell:process sigchld;
allow appdomain adbd:process sigchld;

# child shell or gdbserver pty access for runas.
allow appdomain devpts:chr_file { getattr read write ioctl };

# Use pipes and sockets provided by system_server via binder or local socket.
allow appdomain system_server:fifo_file { { getattr open read ioctl lock } { open append write } };
allow appdomain system_server:unix_stream_socket { read write setopt getattr getopt shutdown };
allow appdomain system_server:tcp_socket { read write getattr getopt shutdown };

# Communication with other apps via fifos
allow appdomain appdomain:fifo_file { { getattr open read ioctl lock } { open append write } };

# Communicate with surfaceflinger.
allow appdomain surfaceflinger:unix_stream_socket { read write setopt getattr getopt shutdown };

# App sandbox file accesses.
allow { appdomain -isolated_app } app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow { appdomain -isolated_app } app_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# lib subdirectory of /data/data dir is system-owned.
allow appdomain system_data_file:dir { open getattr read search ioctl };
allow appdomain system_data_file:file { execute execute_no_trans open execmod };

# Traverse into expanded storage
allow appdomain mnt_expand_file:dir { open getattr read search ioctl };

# Keychain and user-trusted credentials
allow appdomain keychain_data_file:dir { open getattr read search ioctl };
allow appdomain keychain_data_file:file { getattr open read ioctl lock };
allow appdomain misc_user_data_file:dir { open getattr read search ioctl };
allow appdomain misc_user_data_file:file { getattr open read ioctl lock };

# Access to OEM provided data and apps
allow appdomain oemfs:dir { open getattr read search ioctl };
allow appdomain oemfs:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute the shell or other system executables.
allow appdomain shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow appdomain system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow appdomain toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute dex2oat when apps call dexclassloader
allow appdomain dex2oat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Read/write wallpaper file (opened by system).
allow appdomain wallpaper_file:file { getattr read write };

# Write to /data/anr/traces.txt.
allow appdomain anr_data_file:dir search;
allow appdomain anr_data_file:file { open append };

# Allow apps to send dump information to dumpstate
allow appdomain dumpstate:fd use;
allow appdomain dumpstate:unix_stream_socket { read write getopt getattr shutdown };
allow appdomain shell_data_file:file { write getattr };

# Send heap dumps to system_server via an already open file descriptor
# % adb shell am set-watch-heap com.android.systemui 1048576
# % adb shell dumpsys procstats --start-testing
# debuggable builds only.


# Write to /proc/net/xt_qtaguid/ctrl file.
allow appdomain qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
# Everybody can read the xt_qtaguid resource tracking misc dev.
# So allow all apps to read from /dev/xt_qtaguid.
allow appdomain qtaguid_device:chr_file { getattr open read ioctl lock };

# Grant GPU access to all processes started by Zygote.
# They need that to render the standard UI.
allow { appdomain -isolated_app } gpu_device:chr_file { { { getattr open read ioctl lock } { open append write } } execute };
auditallow { appdomain -isolated_app } gpu_device:chr_file execute;

# Use the Binder.

# Call the servicemanager and transfer references to it.
allow appdomain servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager appdomain:dir search;
allow servicemanager appdomain:file { read open };
allow servicemanager appdomain:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.

# Perform binder IPC to binder services.

# Call the server domain and optionally transfer references to it.
allow appdomain binderservicedomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow binderservicedomain appdomain:binder transfer;
# Receive and use open files from the server.
allow appdomain binderservicedomain:fd use;

# Perform binder IPC to other apps.

# Call the server domain and optionally transfer references to it.
allow appdomain appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain appdomain:binder transfer;
# Receive and use open files from the server.
allow appdomain appdomain:fd use;


# Already connected, unnamed sockets being passed over some other IPC
# hence no sock_file or connectto permission. This appears to be how
# Chrome works, may need to be updated as more apps using isolated services
# are examined.
allow appdomain appdomain:unix_stream_socket { getopt getattr read write shutdown };

# Backup ability for every app. BMS opens and passes the fd
# to any app that has backup ability. Hence, no open permissions here.
allow appdomain backup_data_file:file { read write getattr };
allow appdomain cache_backup_file:file { read write getattr };
allow appdomain cache_backup_file:dir getattr;
# Backup ability using 'adb backup'
allow appdomain system_data_file:lnk_file getattr;

# Allow read/stat of /data/media files passed by Binder or local socket IPC.
allow appdomain media_rw_data_file:file { read getattr };

# Read and write /data/data/com.android.providers.telephony files passed over Binder.
allow appdomain radio_data_file:file { read write getattr };

# Allow access to external storage; we have several visible mount points under /storage
# and symlinks to primary storage at places like /storage/sdcard0 and /mnt/user/0/primary
allow appdomain storage_file:dir { open getattr read search ioctl };
allow appdomain storage_file:lnk_file { getattr open read ioctl lock };
allow appdomain mnt_user_file:dir { open getattr read search ioctl };
allow appdomain mnt_user_file:lnk_file { getattr open read ioctl lock };

# Read/write visible storage
allow appdomain fuse:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow appdomain fuse:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access OBBs (vfat images) mounted by vold (b/17633509)
# File write access allowed for FDs returned through Storage Access Framework
allow appdomain vfat:dir { open getattr read search ioctl };
allow appdomain vfat:file { { getattr open read ioctl lock } { open append write } };

# Allow apps to use the USB Accessory interface.
# http://developer.android.com/guide/topics/connectivity/usb/accessory.html
#
# USB devices are first opened by the system server (USBDeviceManagerService)
# and the file descriptor is passed to the right Activity via binder.
allow appdomain usb_device:chr_file { read write getattr ioctl };
allow appdomain usbaccessory_device:chr_file { read write getattr };

# For art.
allow appdomain dalvikcache_data_file:file execute;
allow appdomain dalvikcache_data_file:lnk_file { getattr open read ioctl lock };

# /data/dalvik-cache/profiles
allow appdomain dalvikcache_profiles_data_file:dir { search getattr };
allow appdomain dalvikcache_profiles_data_file:file { { getattr open read ioctl lock } { open append write } };

# Allow any app to read shared RELRO files.
allow appdomain shared_relro_file:dir search;
allow appdomain shared_relro_file:file { getattr open read ioctl lock };

# Allow apps to read/execute installed binaries
allow appdomain apk_data_file:dir { open getattr read search ioctl };
allow appdomain apk_data_file:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } execmod };

# /data/resource-cache
allow appdomain resourcecache_data_file:file { getattr open read ioctl lock };
allow appdomain resourcecache_data_file:dir { open getattr read search ioctl };

# logd access

allow appdomain logcat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



allow appdomain logdr_socket:sock_file write;
allow appdomain logd:unix_stream_socket connectto;




# Group AID_LOG checked by filesystem & logd
# to permit control commands



allow appdomain logd_socket:sock_file write;
allow appdomain logd:unix_stream_socket connectto;



# application inherit logd write socket (urge is to deprecate this long term)
allow appdomain zygote:unix_dgram_socket write;

allow { appdomain -isolated_app } keystore:keystore_key { get_state get insert delete exist list sign verify };


  allow keystore { appdomain -isolated_app }:dir search;
  allow keystore { appdomain -isolated_app }:file { read open };
  allow keystore { appdomain -isolated_app }:process getattr;
  allow { appdomain -isolated_app } keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow { appdomain -isolated_app } keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore { appdomain -isolated_app }:binder transfer;
# Receive and use open files from the server.
allow { appdomain -isolated_app } keystore:fd use;



allow appdomain console_device:chr_file { read write };

###
### CTS-specific rules
###

# For cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java.
# testRunAsHasCorrectCapabilities
allow appdomain runas_exec:file getattr;
# Others are either allowed elsewhere or not desired.

# For cts/tests/tests/security/src/android/security/cts/SELinuxTest.java
# Check SELinux policy and contexts.

allow appdomain selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow appdomain kernel:security compute_av;
allow appdomain self:netlink_selinux_socket *;


allow appdomain selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow appdomain kernel:security check_context;


###
### Neverallow rules
###
### These are things that Android apps should NEVER be able to do
###

# Superuser capabilities.
# bluetooth requires net_admin and wake_alarm.
neverallow { appdomain -bluetooth } self:capability *;
neverallow { appdomain -bluetooth } self:capability2 *;

# Block device access.
neverallow appdomain dev_type:blk_file { read write };

# Access to any of the following character devices.
neverallow appdomain {
    audio_device
    camera_device
    dm_device
    radio_device
    gps_device
    rpmsg_device
}:chr_file { read write };

# Note: Try expanding list of app domains in the future.
neverallow { untrusted_app isolated_app shell } graphics_device:chr_file { read write };

neverallow { appdomain -nfc } nfc_device:chr_file
    { read write };
neverallow { appdomain -bluetooth } hci_attach_dev:chr_file
    { read write };
neverallow appdomain tee_device:chr_file { read write };

# Privileged netlink socket interfaces.
neverallow appdomain
    domain:{
        netlink_firewall_socket
        netlink_tcpdiag_socket
        netlink_nflog_socket
        netlink_xfrm_socket
        netlink_audit_socket
        netlink_ip6fw_socket
        netlink_dnrt_socket
    } *;

# These messages are broadcast messages from the kernel to userspace.
# Do not allow the writing of netlink messages, which has been a source
# of rooting vulns in the past.
neverallow appdomain domain:netlink_kobject_uevent_socket { write append };

# Sockets under /dev/socket that are not specifically typed.
neverallow appdomain socket_device:sock_file write;

# Unix domain sockets.
neverallow appdomain adbd_socket:sock_file write;
neverallow appdomain installd_socket:sock_file write;
neverallow { appdomain -bluetooth -radio -shell -system_app -nfc }
    property_socket:sock_file write;
neverallow { appdomain -radio } rild_socket:sock_file write;
neverallow appdomain vold_socket:sock_file write;
neverallow appdomain zygote_socket:sock_file write;

# ptrace access to non-app domains.
neverallow appdomain { domain -appdomain }:process ptrace;

# Write access to /proc/pid entries for any non-app domain.
neverallow appdomain { domain -appdomain }:file write;

# signal access to non-app domains.
# sigchld allowed for parent death notification.
# signull allowed for kill(pid, 0) existence test.
# All others prohibited.
neverallow appdomain { domain -appdomain }:process
    { sigkill sigstop signal };

# Transition to a non-app domain.
# Exception for the shell domain and the su domain, can transition to runas,
# etc.
neverallow { appdomain -shell  } { domain -appdomain }:process
    { transition dyntransition };

# Write to rootfs.
neverallow appdomain rootfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to /system.
neverallow appdomain system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to entrypoint executables.
neverallow appdomain exec_type:file
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to system-owned parts of /data.
# This is the default type for anything under /data not otherwise
# specified in file_contexts.  Define a different type for portions
# that should be writable by apps.
# Exception for system_app for Settings.
neverallow { appdomain -system_app }
    system_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to various other parts of /data.
neverallow appdomain drm_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -system_app }
    gps_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -shell }
    shell_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -bluetooth }
    bluetooth_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    keystore_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    systemkeys_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    wifi_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    dhcp_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# access tmp apk files
neverallow { appdomain -platform_app -priv_app }
    { apk_tmp_file apk_private_tmp_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } *;

# Access to factory files.
neverallow appdomain efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow { appdomain -shell } efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } read;

# Write to various pseudo file systems.
neverallow { appdomain -bluetooth -nfc }
    sysfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow appdomain
    proc:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Access to syslog(2) or /proc/kmsg.
neverallow { appdomain -system_app }
    kernel:system { syslog_mod syslog_console };
neverallow { appdomain -system_app -shell }
    kernel:system syslog_read;

# Ability to perform any filesystem operation other than statfs(2).
# i.e. no mount(2), unmount(2), etc.
neverallow appdomain fs_type:filesystem ~getattr;

# Ability to set system properties.
neverallow { appdomain -system_app -radio -shell -bluetooth -nfc }
    property_type:property_service set;

# prevent creation/manipulation of globally readable symlinks
neverallow appdomain {
  apk_data_file
  cache_file
  dev_type
  rootfs
  system_file
  security_file
  tmpfs
}:lnk_file { append create link unlink relabelfrom rename setattr write };
# Domain for atrace process spawned by boottrace service.
type atrace_exec, exec_type, file_type;


# Rules common to all binder service domains

# Allow dumpstate to collect information from binder services
allow binderservicedomain dumpstate:fd use;
allow binderservicedomain dumpstate:unix_stream_socket { read write getopt getattr };
allow binderservicedomain shell_data_file:file { getattr write };

# Allow dumpsys to work from adb shell or the serial console
allow binderservicedomain devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow binderservicedomain console_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Receive and write to a pipe received over Binder from an app.
allow binderservicedomain appdomain:fd use;
allow binderservicedomain appdomain:fifo_file write;

allow binderservicedomain keystore:keystore_key { get_state get insert delete exist list sign verify };


  allow keystore binderservicedomain:dir search;
  allow keystore binderservicedomain:file { read open };
  allow keystore binderservicedomain:process getattr;
  allow binderservicedomain keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow binderservicedomain keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore binderservicedomain:binder transfer;
# Receive and use open files from the server.
allow binderservicedomain keystore:fd use;


# blkid called from vold
type blkid, domain;
type blkid_exec, exec_type, file_type;

# Allowed read-only access to encrypted devices to extract UUID/label
allow blkid block_device:dir search;
allow blkid userdata_block_device:blk_file { getattr open read ioctl lock };
allow blkid dm_device:blk_file { getattr open read ioctl lock };

# Allow stdin/out back to vold
allow blkid vold:fd use;
allow blkid vold:fifo_file { read write getattr };

# For blkid launched through popen()
allow blkid blkid_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Only allow entry from vold
neverallow { domain -vold } blkid:process transition;
neverallow domain blkid:process dyntransition;
neverallow blkid { file_type fs_type -blkid_exec -shell_exec }:file entrypoint;
# blkid for untrusted block devices
type blkid_untrusted, domain;

# Allowed read-only access to vold block devices to extract UUID/label
allow blkid_untrusted block_device:dir search;
allow blkid_untrusted vold_device:blk_file { getattr open read ioctl lock };

# Allow stdin/out back to vold
allow blkid_untrusted vold:fd use;
allow blkid_untrusted vold:fifo_file { read write getattr };

# For blkid launched through popen()
allow blkid_untrusted blkid_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

###
### neverallow rules
###

# Untrusted blkid should never be run on block devices holding sensitive data
neverallow blkid_untrusted {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  userdata_block_device
  cache_block_device
  dm_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from vold via blkid binary
neverallow { domain -vold } blkid_untrusted:process transition;
neverallow domain blkid_untrusted:process dyntransition;
neverallow blkid_untrusted { file_type fs_type -blkid_exec -shell_exec }:file entrypoint;
# bluetooth subsystem
type bluetooth, domain;

typeattribute bluetooth appdomain;
# Label ashmem objects with our own unique type.

type bluetooth_tmpfs, file_type;
type_transition bluetooth tmpfs:file bluetooth_tmpfs;
allow bluetooth bluetooth_tmpfs:file { read write };

# Map with PROT_EXEC.
allow bluetooth bluetooth_tmpfs:file execute;


typeattribute bluetooth netdomain;


# Data file accesses.
allow bluetooth bluetooth_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow bluetooth bluetooth_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Socket creation under /data/misc/bluedroid.
type_transition bluetooth bluetooth_data_file:sock_file bluetooth_socket;
allow bluetooth bluetooth_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# bluetooth factory file accesses.

allow bluetooth bluetooth_efs_file:dir { open getattr read search ioctl };
allow bluetooth bluetooth_efs_file:{ file lnk_file } { getattr open read ioctl lock };


# TODO why does bluetooth require access to tun_device? If not,
# remove access and tighten down neverallow rule so that appdomain is
# not allowed to open (as opposed to just untrusted_app)
# Device accesses. b/24744295
allow bluetooth { tun_device uhid_device hci_attach_dev }:chr_file { { getattr open read ioctl lock } { open append write } };
auditallow bluetooth tun_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Other domains that can create and use bluetooth sockets.
# SELinux does not presently define a specific socket class for
# bluetooth sockets, nor does it distinguish among the bluetooth protocols.
# TODO: This should no longer be needed with bluedroid for bluetooth
# but may be getting used for other non-bluetooth sockets that has no
# specific class defined.  Consider taking to specific domains.
allow bluetoothdomain self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# sysfs access.
allow bluetooth sysfs_bluetooth_writable:file { { getattr open read ioctl lock } { open append write } };
allow bluetooth self:capability net_admin;
allow bluetooth self:capability2 wake_alarm;

# Allow clients to use a socket provided by the bluetooth app.
# TODO:  See if this is still required under bluedroid.
allow bluetoothdomain bluetooth:unix_stream_socket { getopt setopt getattr read write ioctl shutdown };

# tethering
allow bluetooth self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow bluetooth efs_file:dir search;

# proc access.
allow bluetooth proc_bluetooth_writable:file { { getattr open read ioctl lock } { open append write } };

# Allow write access to bluetooth specific properties


allow bluetooth property_socket:sock_file write;
allow bluetooth init:unix_stream_socket connectto;

allow bluetooth bluetooth_prop:property_service set;



allow bluetooth property_socket:sock_file write;
allow bluetooth init:unix_stream_socket connectto;

allow bluetooth pan_result_prop:property_service set;



allow bluetooth property_socket:sock_file write;
allow bluetooth init:unix_stream_socket connectto;

allow bluetooth ctl_dhcp_pan_prop:property_service set;


allow bluetooth bluetooth_service:service_manager find;
allow bluetooth drmserver_service:service_manager find;
allow bluetooth mediaserver_service:service_manager find;
allow bluetooth radio_service:service_manager find;
allow bluetooth surfaceflinger_service:service_manager find;
allow bluetooth app_api_service:service_manager find;
allow bluetooth system_api_service:service_manager find;

# Bluetooth Sim Access Profile Socket to the RIL



allow bluetooth sap_uim_socket:sock_file write;
allow bluetooth rild:unix_stream_socket connectto;



# already open bugreport file descriptors may be shared with
# the bluetooth process, from a file in
# /data/data/com.android.shell/files/bugreports/bugreport-*.
allow bluetooth shell_data_file:file read;

###
### Neverallow rules
###
### These are things that the bluetooth app should NEVER be able to do
###

# Superuser capabilities.
# bluetooth requires net_admin and wake_alarm.
neverallow bluetooth self:capability ~net_admin;
neverallow bluetooth self:capability2 ~{ wake_alarm block_suspend };
# bootanimation oneshot service
type bootanim, domain;
type bootanim_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init bootanim_exec:file { getattr open read execute };
allow init bootanim:process transition;
# New domain is entered by executing the file.
allow bootanim bootanim_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow bootanim init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init bootanim:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init bootanim:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init bootanim_exec:process bootanim;


type bootanim_tmpfs, file_type;
type_transition bootanim tmpfs:file bootanim_tmpfs;
allow bootanim bootanim_tmpfs:file { read write };




# Call the servicemanager and transfer references to it.
allow bootanim servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager bootanim:dir search;
allow servicemanager bootanim:file { read open };
allow servicemanager bootanim:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow bootanim surfaceflinger:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow surfaceflinger bootanim:binder transfer;
# Receive and use open files from the server.
allow bootanim surfaceflinger:fd use;


allow bootanim gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# /oem access
allow bootanim oemfs:dir search;
allow bootanim oemfs:file { getattr open read ioctl lock };

allow bootanim audio_device:dir { open getattr read search ioctl };
allow bootanim audio_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow bootanim surfaceflinger_service:service_manager find;
# 464xlat daemon
type clatd, domain;
type clatd_exec, exec_type, file_type;


typeattribute clatd netdomain;


# Access objects inherited from netd.
allow clatd netd:fd use;
allow clatd netd:fifo_file { read write };
# TODO: Check whether some or all of these sockets should be close-on-exec.
allow clatd netd:netlink_kobject_uevent_socket { read write };
allow clatd netd:netlink_nflog_socket { read write };
allow clatd netd:netlink_route_socket { read write };
allow clatd netd:udp_socket { read write };
allow clatd netd:unix_stream_socket { read write };
allow clatd netd:unix_dgram_socket { read write };

allow clatd self:capability { net_admin net_raw setuid setgid };

# clatd calls mmap(MAP_LOCKED) with a 1M buffer. MAP_LOCKED first checks
# capable(CAP_IPC_LOCK), and then checks to see the requested amount is
# under RLIMIT_MEMLOCK. If the latter check succeeds clatd won't have
# needed CAP_IPC_LOCK. But this is not guaranteed to succeed on all devices
# so we permit any requests we see from clatd asking for this capability.
# See https://android-review.googlesource.com/127940 and
# https://b.corp.google.com/issues/21736319
allow clatd self:capability ipc_lock;

allow clatd self:netlink_route_socket nlmsg_write;
allow clatd self:{ packet_socket rawip_socket tun_socket } { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow clatd tun_device:chr_file { { getattr open read ioctl lock } { open append write } };
# debugger interface
type debuggerd, domain;
type debuggerd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init debuggerd_exec:file { getattr open read execute };
allow init debuggerd:process transition;
# New domain is entered by executing the file.
allow debuggerd debuggerd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow debuggerd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init debuggerd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init debuggerd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init debuggerd_exec:process debuggerd;


type debuggerd_tmpfs, file_type;
type_transition debuggerd tmpfs:file debuggerd_tmpfs;
allow debuggerd debuggerd_tmpfs:file { read write };


typeattribute debuggerd mlstrustedsubject;
allow debuggerd self:capability { dac_override sys_ptrace chown kill fowner };
allow debuggerd self:capability2 { syslog };
allow debuggerd domain:dir { open getattr read search ioctl };
allow debuggerd domain:file { getattr open read ioctl lock };
allow debuggerd domain:lnk_file read;
allow debuggerd { domain -init -ueventd -watchdogd -healthd -adbd -keystore }:process { ptrace getattr };

allow debuggerd security_file:dir { open getattr read search ioctl };
allow debuggerd security_file:file { getattr open read ioctl lock };

allow debuggerd system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow debuggerd system_data_file:dir relabelfrom;
allow debuggerd tombstone_data_file:dir relabelto;
allow debuggerd tombstone_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow debuggerd tombstone_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow debuggerd shared_relro_file:dir { open getattr read search ioctl };
allow debuggerd shared_relro_file:file { getattr open read ioctl lock };
allow debuggerd domain:process { sigstop signal };
allow debuggerd exec_type:file { getattr open read ioctl lock };
# Access app library
allow debuggerd system_data_file:file open;
# Allow debuggerd to redirect a dump_backtrace request to itself.
# This only happens on 64 bit systems, where all requests go to the 64 bit
# debuggerd and get redirected to the 32 bit debuggerd if the process is 32 bit.
allow debuggerd { drmserver mediaserver sdcardd surfaceflinger inputflinger }:debuggerd dump_backtrace;

# Connect to system_server via /data/system/ndebugsocket.



allow debuggerd system_ndebug_socket:sock_file write;
allow debuggerd system_server:unix_stream_socket connectto;





# logd access

allow debuggerd logcat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



allow debuggerd logdr_socket:sock_file write;
allow debuggerd logd:unix_stream_socket connectto;




# Check SELinux permissions.

allow debuggerd selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow debuggerd kernel:security compute_av;
allow debuggerd self:netlink_selinux_socket *;

# Device types
type device, dev_type, fs_type;
type alarm_device, dev_type, mlstrustedobject;
type adb_device, dev_type;
type ashmem_device, dev_type, mlstrustedobject;
type audio_device, dev_type;
type binder_device, dev_type, mlstrustedobject;
type block_device, dev_type;
type camera_device, dev_type;
type dm_device, dev_type;
type loop_device, dev_type;
type pmsg_device, dev_type, mlstrustedobject;
type radio_device, dev_type;
type ram_device, dev_type;
type rtc_device, dev_type;
type vold_device, dev_type;
type console_device, dev_type;
type cpuctl_device, dev_type;
type fscklogs, dev_type;
type full_device, dev_type;
# GPU (used by most UI apps)
type gpu_device, dev_type, mlstrustedobject;
type graphics_device, dev_type;
type hw_random_device, dev_type;
type input_device, dev_type;
type kmem_device, dev_type;
type log_device, dev_type, mlstrustedobject;
type mtd_device, dev_type;
type mtp_device, dev_type, mlstrustedobject;
type nfc_device, dev_type;
type ptmx_device, dev_type, mlstrustedobject;
type kmsg_device, dev_type;
type null_device, dev_type, mlstrustedobject;
type random_device, dev_type, mlstrustedobject;
type sensors_device, dev_type;
type serial_device, dev_type;
type socket_device, dev_type;
type owntty_device, dev_type, mlstrustedobject;
type tty_device, dev_type;
type urandom_device, dev_type, mlstrustedobject;
type video_device, dev_type;
type vcs_device, dev_type;
type zero_device, dev_type, mlstrustedobject;
type fuse_device, dev_type;
type iio_device, dev_type;
type ion_device, dev_type, mlstrustedobject;
type gps_device, dev_type;
type qtaguid_device, dev_type;
type watchdog_device, dev_type;
type uhid_device, dev_type;
type uio_device, dev_type;
type tun_device, dev_type, mlstrustedobject;
type usbaccessory_device, dev_type, mlstrustedobject;
type usb_device, dev_type, mlstrustedobject;
type klog_device, dev_type;
type properties_device, dev_type;
type i2c_device, dev_type;

# All devices have a uart for the hci
# attach service. The uart dev node
# varies per device. This type
# is used in per device policy
type hci_attach_dev, dev_type;

# All devices have a rpmsg device for
# achieving remoteproc and rpmsg modules
type rpmsg_device, dev_type;

# Partition layout block device
type root_block_device, dev_type;

# factory reset protection block device
type frp_block_device, dev_type;

# System block device mounted on /system.
type system_block_device, dev_type;

# Recovery block device.
type recovery_block_device, dev_type;

# boot block device.
type boot_block_device, dev_type;

# Userdata block device mounted on /data.
type userdata_block_device, dev_type;

# Cache block device mounted on /cache.
type cache_block_device, dev_type;

# Block device for any swap partition.
type swap_block_device, dev_type;

# Metadata block device used for encryption metadata.
# Assign this type to the partition specified by the encryptable=
# mount option in your fstab file in the entry for userdata.
type metadata_block_device, dev_type;

# The 'misc' partition used by recovery and A/B.
type misc_block_device, dev_type;
# dex2oat
type dex2oat, domain;
type dex2oat_exec, exec_type, file_type;

allow dex2oat dalvikcache_data_file:file write;
# Read symlinks in /data/dalvik-cache
allow dex2oat dalvikcache_data_file:lnk_file read;
allow dex2oat installd:fd use;

# Read already open asec_apk_file file descriptors passed by installd.
# Also allow reading unlabeled files, to allow for upgrading forward
# locked APKs.
allow dex2oat asec_apk_file:file read;
allow dex2oat unlabeled:file read;
allow dex2oat oemfs:file read;
allow dex2oat apk_tmp_file:file read;
type dhcp, domain;
type dhcp_exec, exec_type, file_type;
type dhcp_data_file, file_type, data_file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init dhcp_exec:file { getattr open read execute };
allow init dhcp:process transition;
# New domain is entered by executing the file.
allow dhcp dhcp_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow dhcp init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init dhcp:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init dhcp:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init dhcp_exec:process dhcp;


type dhcp_tmpfs, file_type;
type_transition dhcp tmpfs:file dhcp_tmpfs;
allow dhcp dhcp_tmpfs:file { read write };



typeattribute dhcp netdomain;


allow dhcp cgroup:dir { create write add_name };
allow dhcp self:capability { setgid setuid net_admin net_raw net_bind_service };
allow dhcp self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow dhcp self:netlink_route_socket nlmsg_write;
allow dhcp shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow dhcp system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# XXX Run toolbox.  Might not be needed.
allow dhcp toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow dhcp toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# For /proc/sys/net/ipv4/conf/*/promote_secondaries
allow dhcp proc_net:file write;



allow dhcp property_socket:sock_file write;
allow dhcp init:unix_stream_socket connectto;

allow dhcp dhcp_prop:property_service set;



allow dhcp property_socket:sock_file write;
allow dhcp init:unix_stream_socket connectto;

allow dhcp pan_result_prop:property_service set;


type_transition dhcp system_data_file:{ dir file } dhcp_data_file;
allow dhcp dhcp_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow dhcp dhcp_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# PAN connections
allow dhcp netd:fd use;
allow dhcp netd:fifo_file { { getattr open read ioctl lock } { open append write } };
allow dhcp netd:{ { udp_socket unix_dgram_socket } unix_stream_socket } { read write };
allow dhcp netd:{ netlink_kobject_uevent_socket netlink_route_socket netlink_nflog_socket } { read write };
# DNS, DHCP services
type dnsmasq, domain;
type dnsmasq_exec, exec_type, file_type;


typeattribute dnsmasq netdomain;


# TODO:  Run with dhcp group to avoid need for dac_override.
allow dnsmasq self:capability dac_override;

allow dnsmasq self:capability { net_admin net_raw net_bind_service setgid setuid };

allow dnsmasq dhcp_data_file:dir { open search write add_name remove_name };
allow dnsmasq dhcp_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Inherit and use open files from netd.
allow dnsmasq netd:fd use;
allow dnsmasq netd:fifo_file { read write };
# TODO: Investigate whether these inherited sockets should be closed on exec.
allow dnsmasq netd:netlink_kobject_uevent_socket { read write };
allow dnsmasq netd:netlink_nflog_socket { read write };
allow dnsmasq netd:netlink_route_socket { read write };
allow dnsmasq netd:unix_stream_socket { read write };
allow dnsmasq netd:unix_dgram_socket { read write };
allow dnsmasq netd:udp_socket { read write };
# Rules for all domains.

# Allow reaping by init.
allow domain init:process sigchld;

# Read access to properties mapping.
allow domain kernel:fd use;
allow domain tmpfs:file { read getattr };
allow domain tmpfs:lnk_file { read getattr };

# Search /storage/emulated tmpfs mount.
allow domain tmpfs:dir { open getattr read search ioctl };

# Intra-domain accesses.
allow domain self:process {
    fork
    sigchld
    sigkill
    sigstop
    signull
    signal
    getsched
    setsched
    getsession
    getpgid
    setpgid
    getcap
    setcap
    getattr
    setrlimit
};
allow domain self:fd use;
allow domain self:dir { open getattr read search ioctl };
allow domain self:lnk_file { getattr open read ioctl lock };
allow domain self:{ fifo_file file } { { getattr open read ioctl lock } { open append write } };
allow domain self:unix_dgram_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } sendto };
allow domain self:unix_stream_socket { { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } } connectto };

# Inherit or receive open files from others.
allow domain init:fd use;
allow domain system_server:fd use;

# Connect to adbd and use a socket transferred from it.
# This is used for e.g. adb backup/restore.
allow domain adbd:unix_stream_socket connectto;
allow domain adbd:fd use;
allow domain adbd:unix_stream_socket { getattr getopt ioctl read write shutdown };



###
### Talk to debuggerd.
###
allow domain debuggerd:process sigchld;
allow domain debuggerd:unix_stream_socket connectto;

# Root fs.
allow domain rootfs:dir { open getattr read search ioctl };
allow domain rootfs:file { getattr open read ioctl lock };
allow domain rootfs:lnk_file { getattr open read ioctl lock };

# Device accesses.
allow domain device:dir search;
allow domain dev_type:lnk_file { getattr open read ioctl lock };
allow domain devpts:dir search;
allow domain device:file read;
allow domain socket_device:dir { open getattr read search ioctl };
allow domain owntty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain null_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain zero_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain ashmem_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain binder_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain ptmx_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain alarm_device:chr_file { getattr open read ioctl lock };
allow domain urandom_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain random_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain properties_device:file { getattr open read ioctl lock };
allow domain init:key search;
allow domain vold:key search;

# logd access


allow domain logdw_socket:sock_file write;
allow domain logd:unix_dgram_socket sendto;

allow domain pmsg_device:chr_file { open append write };


# Filesystem accesses.
allow domain fs_type:filesystem getattr;
allow domain fs_type:dir getattr;

# System file accesses.
allow domain system_file:dir { open getattr read search ioctl };
allow domain system_file:file { getattr open read ioctl lock };
allow domain system_file:file execute;
allow domain system_file:lnk_file { getattr open read ioctl lock };

# Read files already opened under /data.
allow domain system_data_file:dir { search getattr };
allow domain system_data_file:file { getattr read };
allow domain system_data_file:lnk_file { getattr open read ioctl lock };

# Read apk files under /data/app.
allow domain apk_data_file:dir { getattr search };
allow domain apk_data_file:file { getattr open read ioctl lock };
allow domain apk_data_file:lnk_file { getattr open read ioctl lock };

# Read /data/dalvik-cache.
allow domain dalvikcache_data_file:dir { search getattr };
allow domain dalvikcache_data_file:file { getattr open read ioctl lock };

# Read already opened /cache files.
allow domain cache_file:dir { open getattr read search ioctl };
allow domain cache_file:file { getattr read };
allow domain cache_file:lnk_file { getattr open read ioctl lock };

# Read timezone related information

allow domain zoneinfo_data_file:dir { open getattr read search ioctl };
allow domain zoneinfo_data_file:{ file lnk_file } { getattr open read ioctl lock };


# For /acct/uid/*/tasks.
allow domain cgroup:dir { search write };
allow domain cgroup:file { open append write };

#Allow access to ion memory allocation device
allow domain ion_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read access to pseudo filesystems.

allow domain proc:dir { open getattr read search ioctl };
allow domain proc:{ file lnk_file } { getattr open read ioctl lock };


allow domain sysfs:dir { open getattr read search ioctl };
allow domain sysfs:{ file lnk_file } { getattr open read ioctl lock };


allow domain sysfs_devices_system_cpu:dir { open getattr read search ioctl };
allow domain sysfs_devices_system_cpu:{ file lnk_file } { getattr open read ioctl lock };


allow domain inotify:dir { open getattr read search ioctl };
allow domain inotify:{ file lnk_file } { getattr open read ioctl lock };


allow domain cgroup:dir { open getattr read search ioctl };
allow domain cgroup:{ file lnk_file } { getattr open read ioctl lock };


allow domain proc_net:dir { open getattr read search ioctl };
allow domain proc_net:{ file lnk_file } { getattr open read ioctl lock };

allow domain proc_cpuinfo:file { getattr open read ioctl lock };

# debugfs access
allow domain debugfs:dir { open getattr read search ioctl };
allow domain debugfs:file { open append write };

# Get SELinux enforcing status.
allow domain selinuxfs:dir { open getattr read search ioctl };
allow domain selinuxfs:file { getattr open read ioctl lock };

# /data/security files
allow domain security_file:dir { search getattr };
allow domain security_file:file getattr;
allow domain security_file:lnk_file { getattr open read ioctl lock };

# World readable asec image contents
allow domain asec_public_file:file { getattr open read ioctl lock };
allow domain { asec_public_file asec_apk_file }:dir { open getattr read search ioctl };

###
### neverallow rules
###

# Do not allow any domain other than init or recovery to create unlabeled files.
neverallow { domain -init -recovery } unlabeled:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } create;

# Limit ability to ptrace or read sensitive /proc/pid files of processes
# with other UIDs to these whitelisted domains.
neverallow {
  domain
  -debuggerd
  -vold
  -dumpstate
  -system_server
  
} self:capability sys_ptrace;

# Limit device node creation to these whitelisted domains.
neverallow {
  domain
  -kernel
  -init
  -ueventd
  -vold
  -recovery
} self:capability mknod;

# Limit raw I/O to these whitelisted domains.
neverallow { domain -kernel -init -recovery -ueventd -watchdogd -healthd -vold -uncrypt -tee } self:capability sys_rawio;

# No process can map low memory (< CONFIG_LSM_MMAP_MIN_ADDR).
neverallow domain self:memprotect mmap_zero;

# No domain needs mac_override as it is unused by SELinux.
neverallow domain self:capability2 mac_override;

# Only recovery needs mac_admin to set contexts not defined in current policy.
neverallow { domain -recovery } self:capability2 mac_admin;

# Only init should be able to load SELinux policies.
# The first load technically occurs while still in the kernel domain,
# but this does not trigger a denial since there is no policy yet.
# Policy reload requires allowing this to the init domain.
neverallow { domain -init } kernel:security load_policy;

# Only init and the system_server can set selinux.reload_policy 1
# to trigger a policy reload.
neverallow { domain -init -system_server } security_prop:property_service set;

# Only init and system_server can write to /data/security, where runtime
# policy updates live.
# Only init can relabel /data/security (for init.rc restorecon_recursive /data).
neverallow { domain -init } security_file:{ dir file lnk_file } { relabelfrom relabelto };
# Only init and system_server can create/setattr directories with this type.
# init is for init.rc mkdir /data/security.
# system_server is for creating subdirectories under /data/security.
neverallow { domain -init -system_server } security_file:dir { create setattr };
# Only system_server can create subdirectories and files under /data/security.
neverallow { domain -system_server } security_file:dir { rename write add_name remove_name rmdir };
neverallow { domain -system_server } security_file:file { create setattr write append unlink link rename };
neverallow { domain -system_server } security_file:lnk_file { create setattr unlink rename };

# Only init prior to switching context should be able to set enforcing mode.
# init starts in kernel domain and switches to init domain via setcon in
# the init.rc, so the setenforce occurs while still in kernel. After
# switching domains, there is never any need to setenforce again by init.
neverallow domain kernel:security setenforce;
neverallow { domain -kernel } kernel:security setcheckreqprot;

# No booleans in AOSP policy, so no need to ever set them.
neverallow domain kernel:security setbool;

# Adjusting the AVC cache threshold.
# Not presently allowed to anything in policy, but possibly something
# that could be set from init.rc.
neverallow { domain -init } kernel:security setsecparam;

# Only init, ueventd and system_server should be able to access HW RNG
neverallow { domain -init -system_server -ueventd } hw_random_device:chr_file *;

# Ensure that all entrypoint executables are in exec_type.
neverallow domain { file_type -exec_type }:file entrypoint;

# Ensure that nothing in userspace can access /dev/mem or /dev/kmem
neverallow { domain -kernel -ueventd -init } kmem_device:chr_file *;
neverallow domain kmem_device:chr_file ~{ create relabelto unlink setattr };

# Only init should be able to configure kernel usermodehelpers or
# security-sensitive proc settings.
neverallow { domain -init } usermodehelper:file { append write };
neverallow { domain -init } proc_security:file { append write };

# No domain should be allowed to ptrace init.
neverallow domain init:process ptrace;

# Init can't do anything with binder calls. If this neverallow rule is being
# triggered, it's probably due to a service with no SELinux domain.
neverallow domain init:binder *;

# Don't allow raw read/write/open access to block_device
# Rather force a relabel to a more specific type
neverallow { domain -kernel -init -recovery -uncrypt } block_device:blk_file { open read write };

# Don't allow raw read/write/open access to generic devices.
# Rather force a relabel to a more specific type.
# init is exempt from this as there are character devices that only it uses.
# ueventd is exempt from this, as it is managing these devices.
neverallow { domain -init -ueventd } device:chr_file { open read write };

# Limit what domains can mount filesystems or change their mount flags.
# sdcard_type / vfat is exempt as a larger set of domains need
# this capability, including device-specific domains.
neverallow { domain -kernel -init -recovery -vold -zygote } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };

#
# Assert that, to the extent possible, we're not loading executable content from
# outside the rootfs or /system partition except for a few whitelisted domains.
#
neverallow {
    domain
    -appdomain
    -dumpstate
    -shell
    
    -system_server
    -zygote
} { file_type -system_file -exec_type }:file execute;
neverallow {
    domain
    -appdomain # for oemfs
    -recovery # for /tmp/update_binary in tmpfs
} { fs_type -rootfs }:file execute;
# Files from cache should never be executed
neverallow domain { cache_file cache_backup_file }:file execute;

# Protect most domains from executing arbitrary content from /data.
neverallow {
  domain
  -untrusted_app
  -priv_app
  -shell
} {
  data_file_type
  -dalvikcache_data_file
  -system_data_file # shared libs in apks
  -apk_data_file
}:file { execute execute_no_trans };

neverallow { domain  } nativetest_data_file:file { execute execute_no_trans };

# Only the init property service should write to /data/property.
neverallow { domain -init } property_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };
neverallow { domain -init } property_data_file:file { append create link unlink relabelfrom rename setattr write };

# Only recovery should be doing writes to /system
neverallow { domain -recovery } { system_file exec_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom append unlink link rename };
neverallow { domain -recovery -kernel } { system_file exec_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } relabelto;

# Don't allow mounting on top of /system files or directories
neverallow domain exec_type:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } mounton;
neverallow { domain -init } system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } mounton;

# Nothing should be writing to files in the rootfs.
neverallow domain rootfs:file { create write setattr relabelto append unlink link rename };

# Restrict context mounts to specific types marked with
# the contextmount_type attribute.
neverallow domain {fs_type -contextmount_type}:filesystem relabelto;

# Ensure that context mount types are not writable, to ensure that
# the write to /system restriction above is not bypassed via context=
# mount to another type.
neverallow { domain -recovery } contextmount_type:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Do not allow service_manager add for default_android_service.
# Instead domains should use a more specific type such as
# system_app_service rather than the generic type.
# New service_types are defined in service.te and new mappings
# from service name to service_type are defined in service_contexts.
neverallow domain default_android_service:service_manager add;

# Require that domains explicitly label unknown properties, and do not allow
# anyone but init to modify unknown properties.
neverallow { domain -init } default_prop:property_service set;

neverallow { domain -init -recovery -system_server } frp_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# No domain other than recovery and update_engine can write to system partition(s).
neverallow { domain -recovery -update_engine } system_block_device:blk_file write;

# No domains other than install_recovery or recovery can write to recovery.
neverallow { domain -install_recovery -recovery } recovery_block_device:blk_file write;

# Only servicemanager should be able to register with binder as the context manager
neverallow { domain -servicemanager } *:binder set_context_mgr;

# Only authorized processes should be writing to files in /data/dalvik-cache
# (excluding /data/dalvik-cache/profiles, which is labeled differently)
neverallow {
  domain
  -init # TODO: limit init to relabelfrom for files
  -zygote
  -installd
  -dex2oat
} dalvikcache_data_file:file { append create link unlink relabelfrom rename setattr write };

neverallow {
  domain
  -init
  -installd
  -dex2oat
  -zygote
} dalvikcache_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };

# Only system_server should be able to send commands via the zygote socket
neverallow { domain -zygote -system_server } zygote:unix_stream_socket connectto;
neverallow { domain -system_server } zygote_socket:sock_file write;

# Android does not support System V IPCs.
#
# The reason for this is due to the fact that, by design, they lead to global
# kernel resource leakage.
#
# For example, there is no way to automatically release a SysV semaphore
# allocated in the kernel when:
#
# - a buggy or malicious process exits
# - a non-buggy and non-malicious process crashes or is explicitly killed.
#
# Killing processes automatically to make room for new ones is an
# important part of Android's application lifecycle implementation. This means
# that, even assuming only non-buggy and non-malicious code, it is very likely
# that over time, the kernel global tables used to implement SysV IPCs will fill
# up.
neverallow domain domain:{ shm sem msg msgq } *;

# Do not mount on top of symlinks, fifos, or sockets.
# Feature parity with Chromium LSM.
neverallow domain { file_type fs_type dev_type }:{ lnk_file fifo_file sock_file } mounton;

# Nobody should be able to execute su on user builds.
# On userdebug/eng builds, only dumpstate, shell, and
# su itself execute su.
neverallow { domain  } su_exec:file { execute execute_no_trans };

# Do not allow the introduction of new execmod rules. Text relocations
# and modification of executable pages are unsafe.
# The only exceptions are for NDK text relocations associated with
# https://code.google.com/p/android/issues/detail?id=23203
# which, long term, need to go away.
neverallow domain {
  file_type
  -system_data_file
  -apk_data_file
  -app_data_file
  -asec_public_file
}:file execmod;

# Do not allow making the stack or heap executable.
# We would also like to minimize execmem but it seems to be
# required by some device-specific service domains.
neverallow domain self:process { execstack execheap };

# prohibit non-zygote spawned processes from using shared libraries
# with text relocations. b/20013628 .
neverallow { domain -appdomain } file_type:file execmod;

neverallow { domain -init } proc:{ file dir } mounton;

# Ensure that all types assigned to processes are included
# in the domain attribute, so that all allow and neverallow rules
# written on domain are applied to all processes.
# This is achieved by ensuring that it is impossible to transition
# from a domain to a non-domain type and vice versa.
neverallow domain ~domain:process { transition dyntransition };
neverallow ~domain domain:process { transition dyntransition };

#
# Only system_app and system_server should be creating or writing
# their files. The proper way to share files is to setup
# type transitions to a more specific type or assigning a type
# to its parent directory via a file_contexts entry.
# Example type transition:
#  mydomain.te:file_type_auto_trans(mydomain, system_data_file, new_file_type)
#
neverallow {
  domain
  -system_server
  -system_app
  -init
  -installd # for relabelfrom and unlink, check for this in explicit neverallow
} system_data_file:file { append create link unlink relabelfrom rename setattr write };
# do not grant anything greater than r_file_perms and relabelfrom unlink
# to installd
neverallow installd system_data_file:file ~{ { getattr open read ioctl lock } relabelfrom unlink };

#
# Only these domains should transition to shell domain. This domain is
# permissible for the "shell user". If you need a process to exec a shell
# script with differing privilege, define a domain and set up a transition.
#
neverallow {
  domain
  -adbd
  -init
  -runas
  -zygote
} shell:process { transition dyntransition };

# Minimize read access to shell- or app-writable symlinks.
# This is to prevent malicious symlink attacks.
neverallow {
  domain
  -appdomain
  -installd
  -uncrypt  # TODO: see if we can remove
} app_data_file:lnk_file read;

neverallow {
  domain
  -shell
  
  -installd
} shell_data_file:lnk_file read;

# In addition to the symlink reading restrictions above, restrict
# write access to shell owned directories. The /data/local/tmp
# directory is untrustworthy, and non-whitelisted domains should
# not be trusting any content in those directories.
neverallow {
  domain
  -adbd
  -dumpstate
  -installd
  -init
  -shell
  -vold
} shell_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };

neverallow {
  domain
  -adbd
  -appdomain
  -dumpstate
  -init
  -installd
  -system_server # why?
  
} shell_data_file:dir { open search };

# Same as above for /data/local/tmp files. We allow shell files
# to be passed around by file descriptor, but not directly opened.
neverallow {
  domain
  -adbd
  -appdomain
  -dumpstate
  -installd
  
} shell_data_file:file open;

# servicemanager is the only process which handles list request
neverallow domain ~servicemanager:service_manager list;

# only service_manager_types can be added to service_manager
neverallow domain ~service_manager_type:service_manager { add find };

# logpersist is only allowed on userdebug/eng builds
neverallow { domain  } misc_logd_file:file { { getattr open read ioctl lock } { open append write } };

# Prevent assigning non property types to properties
neverallow domain ~property_type:property_service set;

# Domain types should never be assigned to any files other
# than the /proc/pid files associated with a process. The
# executable file used to enter a domain should be labeled
# with its own _exec type, not with the domain type.
# Conventionally, this looks something like:
# $ cat mydaemon.te
# type mydaemon, domain;
# type mydaemon_exec, exec_type, file_type;
# init_daemon_domain(mydaemon)
# $ grep mydaemon file_contexts
# /system/bin/mydaemon -- u:object_r:mydaemon_exec:s0
neverallow domain domain:file { execute execute_no_trans entrypoint };
# drmserver - DRM service
type drmserver, domain;
type drmserver_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init drmserver_exec:file { getattr open read execute };
allow init drmserver:process transition;
# New domain is entered by executing the file.
allow drmserver drmserver_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow drmserver init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init drmserver:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init drmserver:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init drmserver_exec:process drmserver;


type drmserver_tmpfs, file_type;
type_transition drmserver tmpfs:file drmserver_tmpfs;
allow drmserver drmserver_tmpfs:file { read write };


typeattribute drmserver mlstrustedsubject;


typeattribute drmserver netdomain;


# Perform Binder IPC to system server.

# Call the servicemanager and transfer references to it.
allow drmserver servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager drmserver:dir search;
allow servicemanager drmserver:file { read open };
allow servicemanager drmserver:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow drmserver system_server:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow system_server drmserver:binder transfer;
# Receive and use open files from the server.
allow drmserver system_server:fd use;


# Call the server domain and optionally transfer references to it.
allow drmserver appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain drmserver:binder transfer;
# Receive and use open files from the server.
allow drmserver appdomain:fd use;


typeattribute drmserver binderservicedomain;


# Perform Binder IPC to mediaserver

# Call the server domain and optionally transfer references to it.
allow drmserver mediaserver:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow mediaserver drmserver:binder transfer;
# Receive and use open files from the server.
allow drmserver mediaserver:fd use;


allow drmserver sdcard_type:dir search;
allow drmserver drm_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow drmserver drm_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow drmserver tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow drmserver app_data_file:file { read write getattr };
allow drmserver sdcard_type:file { read write getattr };

allow drmserver efs_file:dir { open getattr read search ioctl };
allow drmserver efs_file:{ file lnk_file } { getattr open read ioctl lock };


type drmserver_socket, file_type;

# /data/app/tlcd_sock socket file.
# Clearly, /data/app is the most logical place to create a socket.  Not.
allow drmserver apk_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
type_transition drmserver apk_data_file:sock_file drmserver_socket;
allow drmserver drmserver_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow drmserver tee:unix_stream_socket connectto;
# Delete old socket file if present.
allow drmserver apk_data_file:sock_file unlink;

# After taking a video, drmserver looks at the video file.

allow drmserver media_rw_data_file:dir { open getattr read search ioctl };
allow drmserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock };


# Read resources from open apk files passed over Binder.
allow drmserver apk_data_file:file { read getattr };
allow drmserver asec_apk_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow drmserver radio_data_file:file { read getattr };

# /oem access
allow drmserver oemfs:dir search;
allow drmserver oemfs:file { getattr open read ioctl lock };

allow drmserver drmserver_service:service_manager { add find };
allow drmserver permission_service:service_manager find;


allow drmserver selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow drmserver kernel:security compute_av;
allow drmserver self:netlink_selinux_socket *;

# dumpstate
type dumpstate, domain, mlstrustedsubject;
type dumpstate_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init dumpstate_exec:file { getattr open read execute };
allow init dumpstate:process transition;
# New domain is entered by executing the file.
allow dumpstate dumpstate_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow dumpstate init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init dumpstate:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init dumpstate:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init dumpstate_exec:process dumpstate;


type dumpstate_tmpfs, file_type;
type_transition dumpstate tmpfs:file dumpstate_tmpfs;
allow dumpstate dumpstate_tmpfs:file { read write };



typeattribute dumpstate netdomain;


# Call the servicemanager and transfer references to it.
allow dumpstate servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager dumpstate:dir search;
allow servicemanager dumpstate:file { read open };
allow servicemanager dumpstate:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Allow setting process priority, protect from OOM killer, and dropping
# privileges by switching UID / GID
allow dumpstate self:capability { setuid setgid sys_resource };

# Allow dumpstate to scan through /proc/pid for all processes

allow dumpstate domain:dir { open getattr read search ioctl };
allow dumpstate domain:{ file lnk_file } { getattr open read ioctl lock };


# Send signals to processes
allow dumpstate self:capability kill;

# Allow executing files on system, such as:
#   /system/bin/toolbox
#   /system/bin/logcat
#   /system/bin/dumpsys
allow dumpstate system_file:file execute_no_trans;
allow dumpstate toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Create and write into /data/anr/
allow dumpstate self:capability { dac_override chown fowner fsetid };
allow dumpstate anr_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow dumpstate anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Allow reading /data/system/uiderrors.txt
# TODO: scope this down.
allow dumpstate system_data_file:file { getattr open read ioctl lock };

# Read dmesg
allow dumpstate self:capability2 syslog;
allow dumpstate kernel:system syslog_read;

# Read /sys/fs/pstore/console-ramoops
allow dumpstate pstorefs:dir { open getattr read search ioctl };
allow dumpstate pstorefs:file { getattr open read ioctl lock };

# Get process attributes
allow dumpstate domain:process getattr;

# Signal java processes to dump their stack
allow dumpstate { appdomain system_server }:process signal;

# Signal native processes to dump their stack.
# This list comes from native_processes_to_dump in dumpstate/utils.c
allow dumpstate { drmserver mediaserver sdcardd surfaceflinger }:process signal;
# Ask debuggerd for the backtraces of these processes.
allow dumpstate { drmserver mediaserver sdcardd surfaceflinger }:debuggerd dump_backtrace;

# Execute and transition to the vdc domain

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow dumpstate vdc_exec:file { getattr open read execute };
allow dumpstate vdc:process transition;
# New domain is entered by executing the file.
allow vdc vdc_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow vdc dumpstate:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit dumpstate vdc:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow dumpstate vdc:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition dumpstate vdc_exec:process vdc;


# Vibrate the device after we're done collecting the bugreport
# /sys/class/timed_output/vibrator/enable
# TODO: create a new file class, instead of allowing write access to all of /sys
allow dumpstate sysfs:file { open append write };

# Other random bits of data we want to collect
allow dumpstate qtaguid_proc:file { getattr open read ioctl lock };
allow dumpstate debugfs:file { getattr open read ioctl lock };
# df for /storage/emulated needs search
allow dumpstate storage_file:dir search;

# Allow dumpstate to make binder calls to any binder service

# Call the server domain and optionally transfer references to it.
allow dumpstate binderservicedomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow binderservicedomain dumpstate:binder transfer;
# Receive and use open files from the server.
allow dumpstate binderservicedomain:fd use;


# Call the server domain and optionally transfer references to it.
allow dumpstate appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain dumpstate:binder transfer;
# Receive and use open files from the server.
allow dumpstate appdomain:fd use;


# Reading /proc/PID/maps of other processes
allow dumpstate self:capability sys_ptrace;

# Allow the bugreport service to create a file in
# /data/data/com.android.shell/files/bugreports/bugreport
allow dumpstate shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow dumpstate shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Run a shell.
allow dumpstate shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# For running am and similar framework commands.
# Run /system/bin/app_process.
allow dumpstate zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# Dalvik Compiler JIT.
allow dumpstate ashmem_device:chr_file execute;
allow dumpstate dumpstate_tmpfs:file execute;
allow dumpstate self:process execmem;
# For art.
allow dumpstate dalvikcache_data_file:file execute;
allow dumpstate dalvikcache_data_file:lnk_file { getattr open read ioctl lock };

# Dumpstate calls screencap, which grabs a screenshot. Needs gpu access
allow dumpstate gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# logd access

allow dumpstate logcat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



allow dumpstate logdr_socket:sock_file write;
allow dumpstate logd:unix_stream_socket connectto;




# Group AID_LOG checked by filesystem & logd
# to permit control commands



allow dumpstate logd_socket:sock_file write;
allow dumpstate logd:unix_stream_socket connectto;




# Read network state info files.
allow dumpstate net_data_file:dir search;
allow dumpstate net_data_file:file { getattr open read ioctl lock };

# Access /data/tombstones.
allow dumpstate tombstone_data_file:dir { open getattr read search ioctl };
allow dumpstate tombstone_data_file:file { getattr open read ioctl lock };

allow dumpstate { service_manager_type -gatekeeper_service }:service_manager find;
allow dumpstate servicemanager:service_manager list;

allow dumpstate devpts:chr_file { { getattr open read ioctl lock } { open append write } };
# Filesystem types
type labeledfs, fs_type;
type pipefs, fs_type;
type sockfs, fs_type;
type rootfs, fs_type;
type proc, fs_type;
# Security-sensitive proc nodes that should not be writable to most.
type proc_security, fs_type;
# Type for /proc/sys/vm/drop_caches
type proc_drop_caches, fs_type;
# proc, sysfs, or other nodes that permit configuration of kernel usermodehelpers.
type usermodehelper, fs_type, sysfs_type;
type qtaguid_proc, fs_type, mlstrustedobject;
type proc_bluetooth_writable, fs_type;
type proc_cpuinfo, fs_type;
type proc_iomem, fs_type;
type proc_net, fs_type;
type proc_sysrq, fs_type;
type proc_uid_cputime_showstat, fs_type;
type proc_uid_cputime_removeuid, fs_type;
type selinuxfs, fs_type, mlstrustedobject;
type cgroup, fs_type, mlstrustedobject;
type sysfs, fs_type, sysfs_type, mlstrustedobject;
type sysfs_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_bluetooth_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_nfc_power_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_wake_lock, fs_type, sysfs_type;
type sysfs_mac_address, fs_type, sysfs_type;
# /sys/devices/system/cpu
type sysfs_devices_system_cpu, fs_type, sysfs_type;
# /sys/module/lowmemorykiller
type sysfs_lowmemorykiller, fs_type, sysfs_type;
type inotify, fs_type, mlstrustedobject;
type devpts, fs_type, mlstrustedobject;
type tmpfs, fs_type;
type shm, fs_type;
type mqueue, fs_type;
type fuse, sdcard_type, fs_type, mlstrustedobject;
type vfat, sdcard_type, fs_type, mlstrustedobject;
typealias fuse alias sdcard_internal;
typealias vfat alias sdcard_external;
type debugfs, fs_type, mlstrustedobject;
type pstorefs, fs_type;
type functionfs, fs_type;
type oemfs, fs_type, contextmount_type;
type usbfs, fs_type;
type binfmt_miscfs, fs_type;

# File types
type unlabeled, file_type;
# Default type for anything under /system.
type system_file, file_type;
# Type for /system/bin/logcat.
type logcat_exec, exec_type, file_type;
# /cores for coredumps on userdebug / eng builds
type coredump_file, file_type;
# Default type for anything under /data.
type system_data_file, file_type, data_file_type;
# Unencrypted data
type unencrypted_data_file, file_type, data_file_type;
# /data/.layout_version or other installd-created files that
# are created in a system_data_file directory.
type install_data_file, file_type, data_file_type;
# /data/drm - DRM plugin data
type drm_data_file, file_type, data_file_type;
# /data/adb - adb debugging files
type adb_data_file, file_type, data_file_type;
# /data/anr - ANR traces
type anr_data_file, file_type, data_file_type, mlstrustedobject;
# /data/tombstones - core dumps
type tombstone_data_file, file_type, data_file_type;
# /data/app - user-installed apps
type apk_data_file, file_type, data_file_type;
type apk_tmp_file, file_type, data_file_type, mlstrustedobject;
# /data/app-private - forward-locked apps
type apk_private_data_file, file_type, data_file_type;
type apk_private_tmp_file, file_type, data_file_type, mlstrustedobject;
# /data/dalvik-cache
type dalvikcache_data_file, file_type, data_file_type;
# /data/dalvik-cache/profiles
type dalvikcache_profiles_data_file, file_type, data_file_type, mlstrustedobject;
# /data/resource-cache
type resourcecache_data_file, file_type, data_file_type;
# /data/local - writable by shell
type shell_data_file, file_type, data_file_type, mlstrustedobject;
# /data/gps
type gps_data_file, file_type, data_file_type;
# /data/property
type property_data_file, file_type, data_file_type;
# /data/bootchart
type bootchart_data_file, file_type, data_file_type;
# /data/system/heapdump
type heapdump_data_file, file_type, data_file_type, mlstrustedobject;
# /data/nativetest
type nativetest_data_file, file_type, data_file_type;

# Mount locations managed by vold
type mnt_media_rw_file, file_type;
type mnt_user_file, file_type;
type mnt_expand_file, file_type;
type storage_file, file_type;

# Label for storage dirs which are just mount stubs
type mnt_media_rw_stub_file, file_type;
type storage_stub_file, file_type;

# /data/misc subdirectories
type adb_keys_file, file_type, data_file_type;
type audio_data_file, file_type, data_file_type;
type bluetooth_data_file, file_type, data_file_type;
type boottrace_data_file, file_type, data_file_type;
type camera_data_file, file_type, data_file_type;
type gatekeeper_data_file, file_type, data_file_type;
type keychain_data_file, file_type, data_file_type;
type keystore_data_file, file_type, data_file_type;
type media_data_file, file_type, data_file_type;
type media_rw_data_file, file_type, data_file_type, mlstrustedobject;
type misc_user_data_file, file_type, data_file_type;
type net_data_file, file_type, data_file_type;
type nfc_data_file, file_type, data_file_type;
type radio_data_file, file_type, data_file_type, mlstrustedobject;
type shared_relro_file, file_type, data_file_type;
type systemkeys_data_file, file_type, data_file_type;
type vpn_data_file, file_type, data_file_type;
type wifi_data_file, file_type, data_file_type;
type zoneinfo_data_file, file_type, data_file_type;
type vold_data_file, file_type, data_file_type;
type perfprofd_data_file, file_type, data_file_type, mlstrustedobject;

# Compatibility with type names used in vanilla Android 4.3 and 4.4.
typealias audio_data_file alias audio_firmware_file;
# /data/data subdirectories - app sandboxes
type app_data_file, file_type, data_file_type;
# /data/data subdirectory for system UID apps.
type system_app_data_file, file_type, data_file_type, mlstrustedobject;
# Compatibility with type name used in Android 4.3 and 4.4.
typealias app_data_file alias platform_app_data_file;
typealias app_data_file alias download_file;
# Default type for anything under /cache
type cache_file, file_type, mlstrustedobject;
# Type for /cache/.*\.{data|restore} and default
# type for anything under /cache/backup
type cache_backup_file, file_type, mlstrustedobject;
# Default type for anything under /efs
type efs_file, file_type;
# Type for wallpaper file.
type wallpaper_file, file_type, mlstrustedobject;
# /mnt/asec
type asec_apk_file, file_type, data_file_type, mlstrustedobject;
# Elements of asec files (/mnt/asec) that are world readable
type asec_public_file, file_type, data_file_type;
# /data/app-asec
type asec_image_file, file_type, data_file_type;
# /data/backup and /data/secure/backup
type backup_data_file, file_type, data_file_type, mlstrustedobject;
# For /data/security
type security_file, file_type;
# All devices have bluetooth efs files. But they
# vary per device, so this type is used in per
# device policy
type bluetooth_efs_file, file_type;
# Type for fingerprint template file.
type fingerprintd_data_file, file_type, data_file_type;

# Socket types
type adbd_socket, file_type;
type bluetooth_socket, file_type;
type dnsproxyd_socket, file_type, mlstrustedobject;
type dumpstate_socket, file_type;
type fwmarkd_socket, file_type, mlstrustedobject;
type gps_socket, file_type;
type installd_socket, file_type;
type lmkd_socket, file_type;
type logd_socket, file_type, mlstrustedobject;
type logdr_socket, file_type, mlstrustedobject;
type logdw_socket, file_type, mlstrustedobject;
type mdns_socket, file_type;
type mdnsd_socket, file_type, mlstrustedobject;
type misc_logd_file, file_type;
type mtpd_socket, file_type;
type netd_socket, file_type;
type property_socket, file_type;
type racoon_socket, file_type;
type rild_socket, file_type;
type rild_debug_socket, file_type;
type system_wpa_socket, file_type;
type system_ndebug_socket, file_type;
type vold_socket, file_type;
type wpa_socket, file_type;
type zygote_socket, file_type;
type sap_uim_socket, file_type;
# UART (for GPS) control proc file
type gps_control, file_type;

# Allow files to be created in their appropriate filesystems.
allow fs_type self:filesystem associate;
allow sysfs_type sysfs:filesystem associate;
allow file_type labeledfs:filesystem associate;
allow file_type tmpfs:filesystem associate;
allow file_type rootfs:filesystem associate;
allow dev_type tmpfs:filesystem associate;

# It's a bug to assign the file_type attribute and fs_type attribute
# to any type. Do not allow it.
#
# For example, the following is a bug:
#   type apk_data_file, file_type, data_file_type, fs_type;
# Should be:
#   type apk_data_file, file_type, data_file_type;
neverallow fs_type file_type:filesystem associate;
type fingerprintd, domain;
type fingerprintd_exec, exec_type, file_type;

# fingerprintd


# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init fingerprintd_exec:file { getattr open read execute };
allow init fingerprintd:process transition;
# New domain is entered by executing the file.
allow fingerprintd fingerprintd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow fingerprintd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init fingerprintd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init fingerprintd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init fingerprintd_exec:process fingerprintd;


type fingerprintd_tmpfs, file_type;
type_transition fingerprintd tmpfs:file fingerprintd_tmpfs;
allow fingerprintd fingerprintd_tmpfs:file { read write };



# Call the servicemanager and transfer references to it.
allow fingerprintd servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager fingerprintd:dir search;
allow servicemanager fingerprintd:file { read open };
allow servicemanager fingerprintd:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# need to find KeyStore and add self
allow fingerprintd fingerprintd_service:service_manager { add find };

# allow HAL module to read dir contents
allow fingerprintd fingerprintd_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } };

# allow HAL module to read/write/unlink contents of this dir
allow fingerprintd fingerprintd_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

# Need to add auth tokens to KeyStore

  allow keystore fingerprintd:dir search;
  allow keystore fingerprintd:file { read open };
  allow keystore fingerprintd:process getattr;
  allow fingerprintd keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow fingerprintd keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore fingerprintd:binder transfer;
# Receive and use open files from the server.
allow fingerprintd keystore:fd use;


allow fingerprintd keystore:keystore_key { add_auth };

# For permissions checking

# Call the server domain and optionally transfer references to it.
allow fingerprintd system_server:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow system_server fingerprintd:binder transfer;
# Receive and use open files from the server.
allow fingerprintd system_server:fd use;
;
allow fingerprintd permission_service:service_manager find;
# Any fsck program run by init
type fsck, domain;
type fsck_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init fsck_exec:file { getattr open read execute };
allow init fsck:process transition;
# New domain is entered by executing the file.
allow fsck fsck_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow fsck init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init fsck:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init fsck:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init fsck_exec:process fsck;


type fsck_tmpfs, file_type;
type_transition fsck tmpfs:file fsck_tmpfs;
allow fsck fsck_tmpfs:file { read write };



# /dev/__null__ created by init prior to policy load,
# open fd inherited by fsck.
allow fsck tmpfs:chr_file { read write ioctl };

# Inherit and use pty created by android_fork_execvp_ext().
allow fsck devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow fsck vold:fd use;
allow fsck vold:fifo_file { read write getattr };

# Run fsck on certain block devices
allow fsck block_device:dir search;
allow fsck userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
allow fsck cache_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
allow fsck dm_device:blk_file { { getattr open read ioctl lock } { open append write } };

###
### neverallow rules
###

# fsck should never be run on these block devices
neverallow fsck {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  vold_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from init or vold via fsck binaries
neverallow { domain -init -vold } fsck:process transition;
neverallow domain fsck:process dyntransition;
neverallow fsck { file_type fs_type -fsck_exec }:file entrypoint;
# Any fsck program run on untrusted block devices
type fsck_untrusted, domain;

# Inherit and use pty created by android_fork_execvp_ext().
allow fsck_untrusted devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow fsck_untrusted vold:fd use;
allow fsck_untrusted vold:fifo_file { read write getattr };

# Run fsck on vold block devices
allow fsck_untrusted block_device:dir search;
allow fsck_untrusted vold_device:blk_file { { getattr open read ioctl lock } { open append write } };

###
### neverallow rules
###

# Untrusted fsck should never be run on block devices holding sensitive data
neverallow fsck_untrusted {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  userdata_block_device
  cache_block_device
  dm_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from vold via fsck binaries
neverallow { domain -vold } fsck_untrusted:process transition;
neverallow domain fsck_untrusted:process dyntransition;
neverallow fsck_untrusted { file_type fs_type -fsck_exec }:file entrypoint;
type gatekeeperd, domain;
type gatekeeperd_exec, exec_type, file_type;

# gatekeeperd


# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init gatekeeperd_exec:file { getattr open read execute };
allow init gatekeeperd:process transition;
# New domain is entered by executing the file.
allow gatekeeperd gatekeeperd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow gatekeeperd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init gatekeeperd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init gatekeeperd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init gatekeeperd_exec:process gatekeeperd;


type gatekeeperd_tmpfs, file_type;
type_transition gatekeeperd tmpfs:file gatekeeperd_tmpfs;
allow gatekeeperd gatekeeperd_tmpfs:file { read write };



typeattribute gatekeeperd binderservicedomain;


# Call the servicemanager and transfer references to it.
allow gatekeeperd servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager gatekeeperd:dir search;
allow servicemanager gatekeeperd:file { read open };
allow servicemanager gatekeeperd:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.

allow gatekeeperd tee_device:chr_file { { getattr open read ioctl lock } { open append write } };

# need to find KeyStore and add self
allow gatekeeperd gatekeeper_service:service_manager { add find };

# Need to add auth tokens to KeyStore

  allow keystore gatekeeperd:dir search;
  allow keystore gatekeeperd:file { read open };
  allow keystore gatekeeperd:process getattr;
  allow gatekeeperd keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow gatekeeperd keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore gatekeeperd:binder transfer;
# Receive and use open files from the server.
allow gatekeeperd keystore:fd use;


allow gatekeeperd keystore:keystore_key { add_auth };

# For permissions checking
allow gatekeeperd system_server:binder call;
allow gatekeeperd permission_service:service_manager find;
# For parent user ID lookup
allow gatekeeperd user_service:service_manager find;

# for SID file access
allow gatekeeperd gatekeeper_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow gatekeeperd gatekeeper_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

neverallow { domain -gatekeeperd } gatekeeper_service:service_manager add;
# gpsd - GPS daemon
type gpsd, domain;
type gpsd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init gpsd_exec:file { getattr open read execute };
allow init gpsd:process transition;
# New domain is entered by executing the file.
allow gpsd gpsd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow gpsd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init gpsd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init gpsd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init gpsd_exec:process gpsd;


type gpsd_tmpfs, file_type;
type_transition gpsd tmpfs:file gpsd_tmpfs;
allow gpsd gpsd_tmpfs:file { read write };



typeattribute gpsd netdomain;

allow gpsd gps_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow gpsd gps_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Socket is created by the daemon, not by init, and under /data/gps,
# not under /dev/socket.
type_transition gpsd gps_data_file:sock_file gps_socket;
allow gpsd gps_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# XXX Label sysfs files with a specific type?
allow gpsd sysfs:file { { getattr open read ioctl lock } { open append write } };

allow gpsd gps_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Execute the shell or system commands.
allow gpsd shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow gpsd system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow gpsd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

###
### neverallow
###

# gpsd can never have capabilities other than block_suspend
neverallow gpsd self:capability *;
neverallow gpsd self:capability2 ~block_suspend;
type hci_attach, domain;
type hci_attach_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init hci_attach_exec:file { getattr open read execute };
allow init hci_attach:process transition;
# New domain is entered by executing the file.
allow hci_attach hci_attach_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow hci_attach init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init hci_attach:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init hci_attach:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init hci_attach_exec:process hci_attach;


type hci_attach_tmpfs, file_type;
type_transition hci_attach tmpfs:file hci_attach_tmpfs;
allow hci_attach hci_attach_tmpfs:file { read write };



allow hci_attach kernel:system module_request;
allow hci_attach hci_attach_dev:chr_file { { getattr open read ioctl lock } { open append write } };
allow hci_attach bluetooth_efs_file:dir { open getattr read search ioctl };
allow hci_attach bluetooth_efs_file:file { getattr open read ioctl lock };
# healthd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type healthd, domain;

# Write to /dev/kmsg
allow healthd kmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow healthd self:capability { net_admin sys_tty_config };

# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow healthd sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow healthd self:capability2 block_suspend;

allow healthd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Call the servicemanager and transfer references to it.
allow healthd servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager healthd:dir search;
allow servicemanager healthd:file { read open };
allow servicemanager healthd:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


typeattribute healthd binderservicedomain;


# Call the server domain and optionally transfer references to it.
allow healthd system_server:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow system_server healthd:binder transfer;
# Receive and use open files from the server.
allow healthd system_server:fd use;


# Write to state file.
# TODO:  Split into a separate type?
allow healthd sysfs:file write;

###
### healthd: charger mode
###

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow healthd pstorefs:dir { open getattr read search ioctl };
allow healthd pstorefs:file { getattr open read ioctl lock };

allow healthd graphics_device:dir { open getattr read search ioctl };
allow healthd graphics_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow healthd input_device:dir { open getattr read search ioctl };
allow healthd input_device:chr_file { getattr open read ioctl lock };
allow healthd tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow healthd ashmem_device:chr_file execute;
allow healthd self:process execmem;
allow healthd proc_sysrq:file { { getattr open read ioctl lock } { open append write } };
allow healthd self:capability sys_boot;

allow healthd healthd_service:service_manager { add find };

# Healthd needs to tell init to continue the boot
# process when running in charger mode.


allow healthd property_socket:sock_file write;
allow healthd init:unix_stream_socket connectto;

allow healthd system_prop:property_service set;

# userspace wifi access points
type hostapd, domain;
type hostapd_exec, exec_type, file_type;


typeattribute hostapd netdomain;


allow hostapd self:capability { net_admin net_raw setuid setgid };
allow hostapd self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hostapd self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hostapd self:netlink_route_socket nlmsg_write;

allow hostapd wifi_data_file:file { { getattr open read ioctl lock } { open append write } };
allow hostapd wifi_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
type_transition hostapd wifi_data_file:dir wpa_socket "sockets";
type_transition hostapd wifi_data_file:dir wpa_socket "hostapd";
allow hostapd wpa_socket:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow hostapd wpa_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow hostapd netd:fd use;
allow hostapd netd:udp_socket { read write };
allow hostapd netd:fifo_file { read write };
# TODO: Investigate whether these inherited sockets should be closed on exec.
allow hostapd netd:netlink_kobject_uevent_socket { read write };
allow hostapd netd:netlink_nflog_socket { read write };
allow hostapd netd:netlink_route_socket { read write };
allow hostapd netd:unix_stream_socket { read write };
allow hostapd netd:unix_dgram_socket { read write };
# idmap, when executed by installd
type idmap, domain;
type idmap_exec, exec_type, file_type;

# Use open file to /data/resource-cache file inherited from installd.
allow idmap installd:fd use;
allow idmap resourcecache_data_file:file { getattr read write };

# Open and read from target and overlay apk files passed by argument.
allow idmap apk_data_file:file { getattr open read ioctl lock };
# init is its own domain.
type init, domain, mlstrustedsubject;

type init_tmpfs, file_type;
type_transition init tmpfs:file init_tmpfs;
allow init init_tmpfs:file { read write };


# The init domain is entered by execing init.
type init_exec, exec_type, file_type;

# /dev/__null__ node created by init.
allow init tmpfs:chr_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

#
# init direct restorecon calls.
#
# /dev/socket
allow init { device socket_device }:dir relabelto;
# /dev/__properties__
allow init tmpfs:file relabelfrom;
allow init properties_device:file relabelto;

# setrlimit
allow init self:capability sys_resource;

# Remove /dev/.booting, created before initial policy load or restorecon /dev.
allow init tmpfs:file unlink;

# Access pty created for fsck.
allow init devpts:chr_file { read write open };

# Create /dev/fscklogs files.
allow init fscklogs:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access /dev/__null__ node created prior to initial policy load.
allow init tmpfs:chr_file write;

# Access /dev/console.
allow init console_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /dev/tty0.
allow init tty_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Call mount(2).
allow init self:capability sys_admin;

# Create and mount on directories in /.
allow init rootfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow init { rootfs cache_file cgroup storage_file system_data_file system_file }:dir mounton;

# Mount on /dev/usb-ffs/adb.
allow init device:dir mounton;

# Create and remove symlinks in /.
allow init rootfs:lnk_file { create unlink };

# Mount debugfs on /sys/kernel/debug.
allow init sysfs:dir mounton;

# Create cgroups mount points in tmpfs and mount cgroups on them.
allow init tmpfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow init tmpfs:dir mounton;
allow init cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow init cpuctl_device:dir { create mounton };

# Use tmpfs as /data, used for booting when /data is encrypted
allow init tmpfs:dir relabelfrom;

# Create directories under /dev/cpuctl after chowning it to system.
allow init self:capability dac_override;

# Set system clock.
allow init self:capability sys_time;

allow init self:capability { sys_rawio mknod };

# Mounting filesystems from block devices.
allow init dev_type:blk_file { getattr open read ioctl lock };

# Mounting filesystems.
# Only allow relabelto for types used in context= mount options,
# which should all be assigned the contextmount_type attribute.
# This can be done in device-specific policy via type or typeattribute
# declarations.
allow init fs_type:filesystem ~relabelto;
allow init unlabeled:filesystem ~relabelto;
allow init contextmount_type:filesystem relabelto;

# Allow read-only access to context= mounted filesystems.
allow init contextmount_type:dir { open getattr read search ioctl };
allow init contextmount_type:{ file lnk_file sock_file fifo_file } { getattr open read ioctl lock };

# restorecon /adb_keys or any other rootfs files to a more specific type.
allow init rootfs:file relabelfrom;

# mkdir, symlink, write, rm/rmdir, chown/chmod, restorecon/restorecon_recursive from init.rc files.
# chown/chmod require open+read+setattr required for open()+fchown/fchmod().
# system/core/init.rc requires at least cache_file and data_file_type.
# init.<board>.rc files often include device-specific types, so
# we just allow all file types except /system files here.
allow init self:capability { chown fowner fsetid };
allow init {file_type -system_file -exec_type -app_data_file}:dir { create search getattr open read setattr ioctl };
allow init {file_type -system_file -exec_type -keystore_data_file -security_file -app_data_file -shell_data_file -vold_data_file}:dir { write add_name remove_name rmdir relabelfrom };
allow init {file_type -system_file -exec_type -keystore_data_file -security_file -app_data_file -shell_data_file -vold_data_file -misc_logd_file }:file { create getattr open read write setattr relabelfrom unlink };
allow init {file_type -system_file -exec_type -keystore_data_file -security_file -app_data_file -shell_data_file -vold_data_file}:{ sock_file fifo_file } { create getattr open read setattr relabelfrom unlink };
allow init {file_type -system_file -exec_type -keystore_data_file -security_file -app_data_file -shell_data_file -vold_data_file}:lnk_file { create getattr setattr relabelfrom unlink };
allow init {file_type -system_file -exec_type}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } relabelto;
allow init sysfs:{ dir file lnk_file } { getattr relabelfrom };
allow init sysfs_type:{ dir file lnk_file } relabelto;
allow init dev_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow init dev_type:lnk_file create;

# chown/chmod on pseudo files.
allow init { fs_type -contextmount_type -sdcard_type -rootfs }:file { open read setattr };
allow init { fs_type -contextmount_type -sdcard_type -rootfs }:dir  { open read setattr search };

# chown/chmod on devices.
allow init { dev_type -kmem_device }:chr_file { read open setattr };

# Unlabeled file access for upgrades from 4.2.
allow init unlabeled:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } relabelfrom };
allow init unlabeled:{ file lnk_file sock_file fifo_file } { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } relabelfrom };

# Create /data/security from init.rc post-fs-data.
allow init security_file:dir { create setattr };

# Reload policy upon setprop selinux.reload_policy 1.
# Note: this requires the following allow rule
#   allow init kernel:security load_policy;
# which can be configured on a device-by-device basis if needed.

allow init security_file:dir { open getattr read search ioctl };
allow init security_file:{ file lnk_file } { getattr open read ioctl lock };


# Any operation that can modify the kernel ring buffer, e.g. clear
# or a read that consumes the messages that were read.
allow init kernel:system syslog_mod;
allow init self:capability2 syslog;

# Set usermodehelpers and /proc security settings.
allow init usermodehelper:file { { getattr open read ioctl lock } { open append write } };
allow init proc_security:file { { getattr open read ioctl lock } { open append write } };

# Write to /proc/sys/kernel/panic_on_oops.
allow init proc:file { open append write };

# Write to /proc/sys/net/ping_group_range and other /proc/sys/net files.
allow init proc_net:file { open append write };
allow init self:capability net_admin;

# Write to /proc/sysrq-trigger.
allow init proc_sysrq:file { open append write };

# Reboot.
allow init self:capability sys_boot;

# Write to sysfs nodes.
allow init sysfs_type:dir { open getattr read search ioctl };
allow init sysfs_type:file { open append write };

# Transitions to seclabel processes in init.rc

# Old domain may exec the file and transition to the new domain.
allow init rootfs:file { getattr open read execute };
allow init adbd:process transition;
# New domain is entered by executing the file.
allow adbd rootfs:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow adbd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init adbd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init adbd:process { siginh rlimitinh };


# Old domain may exec the file and transition to the new domain.
allow init rootfs:file { getattr open read execute };
allow init healthd:process transition;
# New domain is entered by executing the file.
allow healthd rootfs:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow healthd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init healthd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init healthd:process { siginh rlimitinh };


# Old domain may exec the file and transition to the new domain.
allow init rootfs:file { getattr open read execute };
allow init slideshow:process transition;
# New domain is entered by executing the file.
allow slideshow rootfs:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow slideshow init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init slideshow:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init slideshow:process { siginh rlimitinh };



# Old domain may exec the file and transition to the new domain.
allow init shell_exec:file { getattr open read execute };
allow init shell:process transition;
# New domain is entered by executing the file.
allow shell shell_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow shell init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init shell:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init shell:process { siginh rlimitinh };


# Old domain may exec the file and transition to the new domain.
allow init init_exec:file { getattr open read execute };
allow init ueventd:process transition;
# New domain is entered by executing the file.
allow ueventd init_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow ueventd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init ueventd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init ueventd:process { siginh rlimitinh };


# Old domain may exec the file and transition to the new domain.
allow init init_exec:file { getattr open read execute };
allow init watchdogd:process transition;
# New domain is entered by executing the file.
allow watchdogd init_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow watchdogd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init watchdogd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init watchdogd:process { siginh rlimitinh };

# case where logpersistd is actually logcat -f in logd context (nee: logcatd)


# Support "adb shell stop"
allow init self:capability kill;
allow init domain:process sigkill;

# Init creates keystore's directory on boot, and walks through
# the directory as part of a recursive restorecon.
allow init keystore_data_file:dir { open create read getattr setattr search };
allow init keystore_data_file:file { getattr };

# Init creates vold's directory on boot, and walks through
# the directory as part of a recursive restorecon.
allow init vold_data_file:dir { open create read getattr setattr search };
allow init vold_data_file:file { getattr };

# Init creates /data/local/tmp at boot
allow init shell_data_file:dir { open create read getattr setattr search };
allow init shell_data_file:file { getattr };

# Set UID and GID for services.
allow init self:capability { setuid setgid };

# For bootchart to read the /proc/$pid/cmdline file of each process,
# we need to have following line to allow init to have access
# to different domains.

allow init domain:dir { open getattr read search ioctl };
allow init domain:{ file lnk_file } { getattr open read ioctl lock };


# Use setexeccon(), setfscreatecon(), and setsockcreatecon().
# setexec is for services with seclabel options.
# setfscreate is for labeling directories and socket files.
# setsockcreate is for labeling local/unix domain sockets.
allow init self:process { setexec setfscreate setsockcreate };

# Perform SELinux access checks on setting properties.

allow init selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow init kernel:security compute_av;
allow init self:netlink_selinux_socket *;


# Ask the kernel for the new context on services to label their sockets.
allow init kernel:security compute_create;

# Create sockets for the services.
allow init domain:unix_stream_socket { create bind };
allow init domain:unix_dgram_socket { create bind };

# Create /data/property and files within it.
allow init property_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow init property_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Set any property.
allow init property_type:property_service set;

# Run "ifup lo" to bring up the localhost interface
allow init self:udp_socket { create ioctl };
allow init self:capability net_raw;

# This line seems suspect, as it should not really need to
# set scheduling parameters for a kernel domain task.
allow init kernel:process setsched;

# swapon() needs write access to swap device
# system/core/fs_mgr/fs_mgr.c - fs_mgr_swapon_all
allow init swap_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Read from /dev/hw_random if present.
# system/core/init/init.c - mix_hwrng_into_linux_rng_action
allow init hw_random_device:chr_file { getattr open read ioctl lock };

# Create and access /dev files without a specific type,
# e.g. /dev/.coldboot_done, /dev/.booting
# TODO:  Move these files into their own type unless they are
# only ever accessed by init.
allow init device:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access character devices without a specific type,
# e.g. /dev/keychord.
# TODO: Move these devices into their own type unless they
# are only ever accessed by init.
allow init device:chr_file { { { getattr open read ioctl lock } { open append write } } setattr };

# keychord configuration
allow init self:capability sys_tty_config;

# Access device mapper for setting up dm-verity
allow init dm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow init dm_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Access metadata block device for storing dm-verity state
allow init metadata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Read /sys/fs/pstore/console-ramoops to detect restarts caused
# by dm-verity detecting corrupted blocks
allow init pstorefs:dir search;
allow init pstorefs:file { getattr open read ioctl lock };

# linux keyring configuration
allow init init:key { write search setattr };

# Allow init to create /data/unencrypted
allow init unencrypted_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };




allow init vold_socket:sock_file write;
allow init vold:unix_stream_socket connectto;



###
### neverallow rules
###

# The init domain is only entered via setcon from the kernel domain,
# never via an exec-based transition.
neverallow domain init:process dyntransition;
neverallow { domain -kernel} init:process transition;
neverallow init { file_type fs_type -init_exec }:file entrypoint;

# Never read/follow symlinks created by shell or untrusted apps.
neverallow init shell_data_file:lnk_file read;
neverallow init app_data_file:lnk_file read;

# init should never execute a program without changing to another domain.
neverallow init { file_type fs_type }:file execute_no_trans;

# Init never adds or uses services via service_manager.
neverallow init service_manager_type:service_manager { add find };
neverallow init servicemanager:service_manager list;

# Init should not be creating subdirectories in /data/local/tmp
neverallow init shell_data_file:dir { write add_name remove_name };
# inputflinger
type inputflinger, domain;
type inputflinger_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init inputflinger_exec:file { getattr open read execute };
allow init inputflinger:process transition;
# New domain is entered by executing the file.
allow inputflinger inputflinger_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow inputflinger init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init inputflinger:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init inputflinger:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init inputflinger_exec:process inputflinger;


type inputflinger_tmpfs, file_type;
type_transition inputflinger tmpfs:file inputflinger_tmpfs;
allow inputflinger inputflinger_tmpfs:file { read write };



# Call the servicemanager and transfer references to it.
allow inputflinger servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager inputflinger:dir search;
allow servicemanager inputflinger:file { read open };
allow servicemanager inputflinger:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


typeattribute inputflinger binderservicedomain;



# Call the server domain and optionally transfer references to it.
allow inputflinger system_server:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow system_server inputflinger:binder transfer;
# Receive and use open files from the server.
allow inputflinger system_server:fd use;



# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow inputflinger sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow inputflinger self:capability2 block_suspend;


allow inputflinger inputflinger_service:service_manager { add find };
allow inputflinger input_device:dir { open getattr read search ioctl };
allow inputflinger input_device:chr_file { { getattr open read ioctl lock } { open append write } };
# installer daemon
type installd, domain;
type installd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init installd_exec:file { getattr open read execute };
allow init installd:process transition;
# New domain is entered by executing the file.
allow installd installd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow installd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init installd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init installd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init installd_exec:process installd;


type installd_tmpfs, file_type;
type_transition installd tmpfs:file installd_tmpfs;
allow installd installd_tmpfs:file { read write };


typeattribute installd mlstrustedsubject;
allow installd self:capability { chown dac_override fowner fsetid setgid setuid };

# Allow labeling of files under /data/app/com.example/oat/
allow installd dalvikcache_data_file:dir relabelto;
allow installd dalvikcache_data_file:file { relabelto link };

# Allow movement of APK files between volumes
allow installd apk_data_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } relabelfrom };
allow installd apk_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } relabelfrom link };
allow installd apk_data_file:lnk_file { create read unlink };

allow installd asec_apk_file:file { getattr open read ioctl lock };
allow installd apk_tmp_file:file { { getattr open read ioctl lock } unlink };
allow installd apk_tmp_file:dir { relabelfrom { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } };
allow installd oemfs:dir { open getattr read search ioctl };
allow installd oemfs:file { getattr open read ioctl lock };
allow installd cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd mnt_expand_file:dir { search getattr };
# Check validity of SELinux context before use.

allow installd selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow installd kernel:security check_context;

# Read /seapp_contexts and /data/security/seapp_contexts

allow installd security_file:dir { open getattr read search ioctl };
allow installd security_file:file { getattr open read ioctl lock };


# Search /data/app-asec and stat files in it.
allow installd asec_image_file:dir search;
allow installd asec_image_file:file getattr;

# Create /data/user and /data/user/0 if necessary.
# Also required to initially create /data/data subdirectories
# and lib symlinks before the setfilecon call.  May want to
# move symlink creation after setfilecon in installd.
allow installd system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd system_data_file:lnk_file { create setattr unlink };

# Upgrade /data/media for multi-user if necessary.
allow installd media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd media_rw_data_file:file { getattr unlink };
# restorecon new /data/media directory.
allow installd system_data_file:dir relabelfrom;
allow installd media_rw_data_file:dir relabelto;

# Upgrade /data/misc/keychain for multi-user if necessary.
allow installd misc_user_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd misc_user_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow installd keychain_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd keychain_data_file:file {{ getattr open read ioctl lock } unlink};

# Create /data/.layout_version.* file
type_transition installd system_data_file:file install_data_file;
allow installd install_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Create files under /data/dalvik-cache.
allow installd dalvikcache_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow installd dalvikcache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Create /data/dalvik-cache/profiles.
allow installd dalvikcache_profiles_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow installd dalvikcache_profiles_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Create files under /data/resource-cache.
allow installd resourcecache_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow installd resourcecache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Run dex2oat in its own sandbox.

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow installd dex2oat_exec:file { getattr open read execute };
allow installd dex2oat:process transition;
# New domain is entered by executing the file.
allow dex2oat dex2oat_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow dex2oat installd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit installd dex2oat:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow installd dex2oat:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition installd dex2oat_exec:process dex2oat;


# Run idmap in its own sandbox.

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow installd idmap_exec:file { getattr open read execute };
allow installd idmap:process transition;
# New domain is entered by executing the file.
allow idmap idmap_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow idmap installd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit installd idmap:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow installd idmap:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition installd idmap_exec:process idmap;


# Upgrade from unlabeled userdata.
# Just need enough to remove and/or relabel it.
allow installd unlabeled:dir { getattr search relabelfrom { { open getattr read search ioctl } { open search write add_name remove_name } } rmdir };
allow installd unlabeled:{ file lnk_file sock_file fifo_file } { getattr relabelfrom rename unlink setattr };
# Read pkg.apk file for input during dexopt.
allow installd unlabeled:file { getattr open read ioctl lock };

# Upgrade from before system_app_data_file was used for system UID apps.
# Just need enough to relabel it and to unlink removed package files.
# Directory access covered by earlier rule above.
allow installd system_data_file:{ file lnk_file sock_file fifo_file } { getattr relabelfrom unlink };

# Manage /data/data subdirectories, including initially labeling them
# upon creation via setfilecon or running restorecon_recursive,
# setting owner/mode, creating symlinks within them, and deleting them
# upon package uninstall.
# Types extracted from seapp_contexts type= fields.
allow installd { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } relabelfrom relabelto };
allow installd { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:{ file lnk_file sock_file fifo_file } { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } relabelfrom relabelto };

# Create and use pty created by android_fork_execvp().
allow installd devpts:chr_file { { getattr open read ioctl lock } { open append write } };

# execute toybox for app relocation
allow installd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# service flash_recovery in init.rc
type install_recovery, domain;
type install_recovery_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init install_recovery_exec:file { getattr open read execute };
allow init install_recovery:process transition;
# New domain is entered by executing the file.
allow install_recovery install_recovery_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow install_recovery init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init install_recovery:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init install_recovery:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init install_recovery_exec:process install_recovery;


type install_recovery_tmpfs, file_type;
type_transition install_recovery tmpfs:file install_recovery_tmpfs;
allow install_recovery install_recovery_tmpfs:file { read write };



allow install_recovery self:capability dac_override;

# /system/bin/install-recovery.sh is a shell script.
# Needs to execute /system/bin/sh
allow install_recovery shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute /system/bin/applypatch
allow install_recovery system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

allow install_recovery toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Update the recovery block device based off a diff of the boot block device
allow install_recovery block_device:dir search;
allow install_recovery boot_block_device:blk_file { getattr open read ioctl lock };
allow install_recovery recovery_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Create and delete /cache/saved.file
allow install_recovery cache_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow install_recovery cache_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Write to /proc/sys/vm/drop_caches
allow install_recovery proc_drop_caches:file { open append write };
###
### Services with isolatedProcess=true in their manifest.
###
### This file defines the rules for isolated apps. An "isolated
### app" is an APP with UID between AID_ISOLATED_START (99000)
### and AID_ISOLATED_END (99999).
###
### isolated_app includes all the appdomain rules, plus the
### additional following rules:
###

type isolated_app, domain;

typeattribute isolated_app appdomain;
# Label ashmem objects with our own unique type.

type isolated_app_tmpfs, file_type;
type_transition isolated_app tmpfs:file isolated_app_tmpfs;
allow isolated_app isolated_app_tmpfs:file { read write };

# Map with PROT_EXEC.
allow isolated_app isolated_app_tmpfs:file execute;


# Access already open app data files received over Binder or local socket IPC.
allow isolated_app app_data_file:file { read write getattr lock };

allow isolated_app activity_service:service_manager find;
allow isolated_app display_service:service_manager find;

# Google Breakpad (crash reporter for Chrome) relies on ptrace
# functionality. Without the ability to ptrace, the crash reporter
# tool is broken.
# b/20150694
# https://code.google.com/p/chromium/issues/detail?id=475270
allow isolated_app self:process ptrace;

#####
##### Neverallow
#####

# Isolated apps should not directly open app data files themselves.
neverallow isolated_app app_data_file:file open;

# b/17487348
# Isolated apps can only access two services,
# activity_service and display_service
neverallow isolated_app {
    service_manager_type
    -activity_service
    -display_service
}:service_manager find;

# Isolated apps shouldn't be able to access the driver directly.
neverallow isolated_app gpu_device:chr_file { { { getattr open read ioctl lock } { open append write } } execute };

# Do not allow isolated_app access to /cache
neverallow isolated_app cache_file:dir ~{ { open getattr read search ioctl } };
neverallow isolated_app cache_file:file ~{ read getattr };
# Life begins with the kernel.
type kernel, domain, mlstrustedsubject;

allow kernel self:capability sys_nice;

# Allow init relabel itself.
allow kernel rootfs:file relabelfrom;
allow kernel init_exec:file relabelto;
# TODO: investigate why we need this.
allow kernel init:process share;

# cgroup filesystem initialization prior to setting the cgroup root directory label.
allow kernel unlabeled:dir search;

# Mount usbfs.
allow kernel usbfs:filesystem mount;
allow kernel usbfs:dir search;

# Initial setenforce by init prior to switching to init domain.
# We use dontaudit instead of allow to prevent a kernel spawned userspace
# process from turning off SELinux once enabled.
dontaudit kernel self:security setenforce;

# Write to /proc/1/oom_adj prior to switching to init domain.
allow kernel self:capability sys_resource;

# Init reboot before switching selinux domains under certain error
# conditions. Allow it.
# As part of rebooting, init writes "u" to /proc/sysrq-trigger to
# remount filesystems read-only. /data is not mounted at this point,
# so we could ignore this. For now, we allow it.
allow kernel self:capability sys_boot;
allow kernel proc_sysrq:file { open append write };

# Allow writing to /dev/__kmsg__ which was created prior to
# loading policy
allow kernel tmpfs:chr_file write;

# Set checkreqprot by init.rc prior to switching to init domain.
allow kernel selinuxfs:file write;
allow kernel self:security setcheckreqprot;

# MTP sync (b/15835289)
# kernel thread "loop0", used by the loop block device, for ASECs (b/17158723)
allow kernel { priv_app untrusted_app }:fd use;
# privileged apps have moved to the priv_app domain. Determine
# if this permission is still needed. b/25331459
auditallow kernel untrusted_app:fd use;
allow kernel sdcard_type:file { read write };

# Allow the kernel to read OBB files from app directories. (b/17428116)
# Kernel thread "loop0" reads a vold supplied file descriptor.
# Fixes CTS tests:
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountObbNormal
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountTwoObbs
allow kernel vold:fd use;
allow kernel app_data_file:file read;
allow kernel asec_image_file:file read;


# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow kernel init_exec:file { getattr open read execute };
allow kernel init:process transition;
# New domain is entered by executing the file.
allow init init_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow init kernel:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit kernel init:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow kernel init:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition kernel init_exec:process init;


###
### neverallow rules
###

# The initial task starts in the kernel domain (assigned via
# initial_sid_contexts), but nothing ever transitions to it.
neverallow domain kernel:process { transition dyntransition };

# The kernel domain is never entered via an exec, nor should it
# ever execute a program outside the rootfs without changing to another domain.
# If you encounter an execute_no_trans denial on the kernel domain, then
# possible causes include:
# - The program is a kernel usermodehelper.  In this case, define a domain
#   for the program and domain_auto_trans() to it.
# - You failed to setcon u:r:init:s0 in your init.rc and thus your init
#   program was left in the kernel domain and is now trying to execute
#   some other program.  Fix your init.rc file.
# - You are running an exploit which switched to the init task credentials
#   and is then trying to exec a shell or other program.  You lose!
neverallow kernel { file_type fs_type -rootfs }:file { entrypoint execute_no_trans };
type keystore, domain;
type keystore_exec, exec_type, file_type;

# keystore daemon


# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init keystore_exec:file { getattr open read execute };
allow init keystore:process transition;
# New domain is entered by executing the file.
allow keystore keystore_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow keystore init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init keystore:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init keystore:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init keystore_exec:process keystore;


type keystore_tmpfs, file_type;
type_transition keystore tmpfs:file keystore_tmpfs;
allow keystore keystore_tmpfs:file { read write };


typeattribute keystore mlstrustedsubject;

# Call the servicemanager and transfer references to it.
allow keystore servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager keystore:dir search;
allow servicemanager keystore:file { read open };
allow servicemanager keystore:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


typeattribute keystore binderservicedomain;

allow keystore keystore_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow keystore keystore_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow keystore keystore_exec:file { getattr };
allow keystore tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow keystore tee:unix_stream_socket connectto;

allow keystore keystore_service:service_manager { add find };

# Check SELinux permissions.

allow keystore selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow keystore kernel:security compute_av;
allow keystore self:netlink_selinux_socket *;


###
### Neverallow rules
###
### Protect ourself from others
###

neverallow { domain -keystore } keystore_data_file:dir ~{ open create read getattr setattr search relabelto ioctl };
neverallow { domain -keystore } keystore_data_file:{ file lnk_file sock_file fifo_file } ~{ relabelto getattr };

neverallow { domain -keystore -init } keystore_data_file:dir *;
neverallow { domain -keystore -init } keystore_data_file:{ file lnk_file sock_file fifo_file } *;

neverallow domain keystore:process ptrace;
# lmkd low memory killer daemon
type lmkd, domain, mlstrustedsubject;
type lmkd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init lmkd_exec:file { getattr open read execute };
allow init lmkd:process transition;
# New domain is entered by executing the file.
allow lmkd lmkd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow lmkd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init lmkd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init lmkd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init lmkd_exec:process lmkd;


type lmkd_tmpfs, file_type;
type_transition lmkd tmpfs:file lmkd_tmpfs;
allow lmkd lmkd_tmpfs:file { read write };



allow lmkd self:capability { dac_override sys_resource kill };

# lmkd locks itself in memory, to prevent it from being
# swapped out and unable to kill other memory hogs.
# system/core commit b28ff9131363f7b4a698990da5748b2a88c3ed35
# b/16236289
allow lmkd self:capability ipc_lock;

## Open and write to /proc/PID/oom_score_adj
## TODO: maybe scope this down?

allow lmkd appdomain:dir { open getattr read search ioctl };
allow lmkd appdomain:{ file lnk_file } { getattr open read ioctl lock };

allow lmkd appdomain:file write;

allow lmkd system_server:dir { open getattr read search ioctl };
allow lmkd system_server:{ file lnk_file } { getattr open read ioctl lock };

allow lmkd system_server:file write;

## Writes to /sys/module/lowmemorykiller/parameters/minfree
allow lmkd sysfs_lowmemorykiller:file { open append write };

# Send kill signals
allow lmkd appdomain:process sigkill;

# Clean up old cgroups
allow lmkd cgroup:dir { remove_name rmdir };

# Set self to SCHED_FIFO
allow lmkd self:capability sys_nice;

### neverallow rules

# never honor LD_PRELOAD
neverallow domain lmkd:process noatsecure;
# android user-space log manager
type logd, domain, mlstrustedsubject;
type logd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init logd_exec:file { getattr open read execute };
allow init logd:process transition;
# New domain is entered by executing the file.
allow logd logd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow logd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init logd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init logd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init logd_exec:process logd;


type logd_tmpfs, file_type;
type_transition logd tmpfs:file logd_tmpfs;
allow logd logd_tmpfs:file { read write };



allow logd self:capability { setuid setgid sys_nice audit_control };
allow logd self:capability2 syslog;
allow logd self:netlink_audit_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_write };
allow logd kernel:system syslog_read;
allow logd kmsg_device:chr_file { open append write };
allow logd system_data_file:file { getattr open read ioctl lock };
# logpersist is only allowed on userdebug and eng builds

allow logd pstorefs:dir search;
allow logd pstorefs:file { getattr open read ioctl lock };


allow logd domain:dir { open getattr read search ioctl };
allow logd domain:{ file lnk_file } { getattr open read ioctl lock };


allow logd kernel:system syslog_mod;


# Group AID_LOG checked by filesystem & logd
# to permit control commands



allow logd logd_socket:sock_file write;
allow logd logd:unix_stream_socket connectto;




# case where logpersistd is actually logcat -f in logd context (nee: logcatd)


###
### Neverallow rules
###
### logd should NEVER do any of this

# Block device access.
neverallow logd dev_type:blk_file { read write };

# ptrace any other app
neverallow logd domain:process ptrace;

# Write to /system.
neverallow logd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow logd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# logd is not allowed to write anywhere other than /misc/data/logd, and then
# only on userdebug or eng builds
neverallow logd { file_type -logd_tmpfs  }:file write;
# mdns daemon
type mdnsd, domain, mlstrustedsubject;
type mdnsd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init mdnsd_exec:file { getattr open read execute };
allow init mdnsd:process transition;
# New domain is entered by executing the file.
allow mdnsd mdnsd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow mdnsd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init mdnsd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init mdnsd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init mdnsd_exec:process mdnsd;


type mdnsd_tmpfs, file_type;
type_transition mdnsd tmpfs:file mdnsd_tmpfs;
allow mdnsd mdnsd_tmpfs:file { read write };



typeattribute mdnsd netdomain;

# mediaserver - multimedia daemon
type mediaserver, domain;
type mediaserver_exec, exec_type, file_type;

typeattribute mediaserver mlstrustedsubject;


typeattribute mediaserver netdomain;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init mediaserver_exec:file { getattr open read execute };
allow init mediaserver:process transition;
# New domain is entered by executing the file.
allow mediaserver mediaserver_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow mediaserver init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init mediaserver:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init mediaserver:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init mediaserver_exec:process mediaserver;


type mediaserver_tmpfs, file_type;
type_transition mediaserver tmpfs:file mediaserver_tmpfs;
allow mediaserver mediaserver_tmpfs:file { read write };




allow mediaserver sdcard_type:dir { open getattr read search ioctl };
allow mediaserver sdcard_type:{ file lnk_file } { getattr open read ioctl lock };



# Call the servicemanager and transfer references to it.
allow mediaserver servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager mediaserver:dir search;
allow servicemanager mediaserver:file { read open };
allow servicemanager mediaserver:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow mediaserver binderservicedomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow binderservicedomain mediaserver:binder transfer;
# Receive and use open files from the server.
allow mediaserver binderservicedomain:fd use;


# Call the server domain and optionally transfer references to it.
allow mediaserver appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain mediaserver:binder transfer;
# Receive and use open files from the server.
allow mediaserver appdomain:fd use;


typeattribute mediaserver binderservicedomain;


# Required by Widevine DRM (b/22990512)
allow mediaserver self:process execmem;

allow mediaserver kernel:system module_request;
allow mediaserver media_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow mediaserver media_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow mediaserver app_data_file:dir search;
allow mediaserver app_data_file:file { { getattr open read ioctl lock } { open append write } };
allow mediaserver sdcard_type:file write;
allow mediaserver gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver video_device:dir { open getattr read search ioctl };
allow mediaserver video_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver audio_device:dir { open getattr read search ioctl };
allow mediaserver tee_device:chr_file { { getattr open read ioctl lock } { open append write } };



allow mediaserver property_socket:sock_file write;
allow mediaserver init:unix_stream_socket connectto;

allow mediaserver audio_prop:property_service set;


# Access audio devices at all.
allow mediaserver audio_device:chr_file { { getattr open read ioctl lock } { open append write } };

# XXX Label with a specific type?
allow mediaserver sysfs:file { getattr open read ioctl lock };

# Read resources from open apk files passed over Binder.
allow mediaserver apk_data_file:file { read getattr };
allow mediaserver asec_apk_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow mediaserver radio_data_file:file { read getattr };

# Use pipes passed over Binder from app domains.
allow mediaserver appdomain:fifo_file { getattr read write };

# Access camera device.
allow mediaserver camera_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver rpmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Inter System processes communicate over named pipe (FIFO)
allow mediaserver system_server:fifo_file { getattr open read ioctl lock };

# Camera data

allow mediaserver camera_data_file:dir { open getattr read search ioctl };
allow mediaserver camera_data_file:{ file lnk_file } { getattr open read ioctl lock };


allow mediaserver media_rw_data_file:dir { open getattr read search ioctl };
allow mediaserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock };


# Grant access to audio files to mediaserver
allow mediaserver audio_data_file:dir { { open getattr read search ioctl } add_name write };
allow mediaserver audio_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Read/[write] to /proc/net/xt_qtaguid/ctrl and /dev/xt_qtaguid
allow mediaserver qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
allow mediaserver qtaguid_device:chr_file { getattr open read ioctl lock };

# Allow abstract socket connection
allow mediaserver rild:unix_stream_socket { connectto read write setopt };

# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.



allow mediaserver drmserver_socket:sock_file write;
allow mediaserver drmserver:unix_stream_socket connectto;



# Needed on some devices for playing audio on paired BT device,
# but seems appropriate for all devices.



allow mediaserver bluetooth_socket:sock_file write;
allow mediaserver bluetooth:unix_stream_socket connectto;



# Connect to tee service.
allow mediaserver tee:unix_stream_socket connectto;

allow mediaserver activity_service:service_manager find;
allow mediaserver appops_service:service_manager find;
allow mediaserver cameraproxy_service:service_manager find;
allow mediaserver batterystats_service:service_manager find;
allow mediaserver drmserver_service:service_manager find;
allow mediaserver mediaserver_service:service_manager { add find };
allow mediaserver permission_service:service_manager find;
allow mediaserver power_service:service_manager find;
allow mediaserver processinfo_service:service_manager find;
allow mediaserver scheduling_policy_service:service_manager find;
allow mediaserver surfaceflinger_service:service_manager find;

# /oem access
allow mediaserver oemfs:dir search;
allow mediaserver oemfs:file { getattr open read ioctl lock };


  allow drmserver mediaserver:dir search;
  allow drmserver mediaserver:file { read open };
  allow drmserver mediaserver:process getattr;

allow mediaserver drmserver:drmservice {
    consumeRights
    setPlaybackStatus
    openDecryptSession
    closeDecryptSession
    initializeDecryptUnit
    decrypt
    finalizeDecryptUnit
    pread
};

###
### neverallow rules
###

# mediaserver should never execute any executable without a
# domain transition
neverallow mediaserver { file_type fs_type }:file execute_no_trans;
# vpn tunneling protocol manager
type mtp, domain;
type mtp_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init mtp_exec:file { getattr open read execute };
allow init mtp:process transition;
# New domain is entered by executing the file.
allow mtp mtp_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow mtp init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init mtp:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init mtp:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init mtp_exec:process mtp;


type mtp_tmpfs, file_type;
type_transition mtp tmpfs:file mtp_tmpfs;
allow mtp mtp_tmpfs:file { read write };



typeattribute mtp netdomain;


# pptp policy
allow mtp self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow mtp self:capability net_raw;
allow mtp ppp:process signal;
allow mtp vpn_data_file:dir search;
# network manager
type netd, domain, mlstrustedsubject;
type netd_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init netd_exec:file { getattr open read execute };
allow init netd:process transition;
# New domain is entered by executing the file.
allow netd netd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow netd init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init netd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init netd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init netd_exec:process netd;


type netd_tmpfs, file_type;
type_transition netd tmpfs:file netd_tmpfs;
allow netd netd_tmpfs:file { read write };



typeattribute netd netdomain;


allow netd self:capability { net_admin net_raw kill };
# Note: fsetid is deliberately not included above. fsetid checks are
# triggered by chmod on a directory or file owned by a group other
# than one of the groups assigned to the current process to see if
# the setgid bit should be cleared, regardless of whether the setgid
# bit was even set.  We do not appear to truly need this capability
# for netd to operate.
dontaudit netd self:capability fsetid;

allow netd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_route_socket nlmsg_write;
allow netd self:netlink_nflog_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow netd system_file:file { getattr execute execute_no_trans };
# XXX Run toolbox.  Might not be needed.
allow netd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow netd toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow netd devpts:chr_file { { getattr open read ioctl lock } { open append write } };

# For /proc/sys/net/ipv[46]/route/flush.
allow netd proc_net:file write;

# For /sys/modules/bcmdhd/parameters/firmware_path
# XXX Split into its own type.
allow netd sysfs:file write;

# Set dhcp lease for PAN connection


allow netd property_socket:sock_file write;
allow netd init:unix_stream_socket connectto;

allow netd dhcp_prop:property_service set;



allow netd property_socket:sock_file write;
allow netd init:unix_stream_socket connectto;

allow netd system_prop:property_service set;

auditallow netd system_prop:property_service set;

# Connect to PAN

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow netd dhcp_exec:file { getattr open read execute };
allow netd dhcp:process transition;
# New domain is entered by executing the file.
allow dhcp dhcp_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow dhcp netd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit netd dhcp:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow netd dhcp:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition netd dhcp_exec:process dhcp;

allow netd dhcp:process signal;

# Needed to update /data/misc/wifi/hostapd.conf
# TODO: See what we can do to reduce the need for
# these capabilities
allow netd self:capability { dac_override chown fowner };
allow netd wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow netd wifi_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

# Needed to update /data/misc/net/rt_tables
allow netd net_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow netd net_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

# Allow netd to spawn hostapd in it's own domain

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow netd hostapd_exec:file { getattr open read execute };
allow netd hostapd:process transition;
# New domain is entered by executing the file.
allow hostapd hostapd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow hostapd netd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit netd hostapd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow netd hostapd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition netd hostapd_exec:process hostapd;

allow netd hostapd:process signal;

# Allow netd to spawn dnsmasq in it's own domain

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow netd dnsmasq_exec:file { getattr open read execute };
allow netd dnsmasq:process transition;
# New domain is entered by executing the file.
allow dnsmasq dnsmasq_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow dnsmasq netd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit netd dnsmasq:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow netd dnsmasq:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition netd dnsmasq_exec:process dnsmasq;

allow netd dnsmasq:process signal;

# Allow netd to start clatd in its own domain

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow netd clatd_exec:file { getattr open read execute };
allow netd clatd:process transition;
# New domain is entered by executing the file.
allow clatd clatd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow clatd netd:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit netd clatd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow netd clatd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition netd clatd_exec:process clatd;

allow netd clatd:process signal;



allow netd property_socket:sock_file write;
allow netd init:unix_stream_socket connectto;

allow netd ctl_mdnsd_prop:property_service set;


# Allow netd to operate on sockets that are passed to it.
allow netd netdomain:{tcp_socket udp_socket rawip_socket dccp_socket tun_socket} {read write getattr setattr getopt setopt};
allow netd netdomain:fd use;

###
### Neverallow rules
###
### netd should NEVER do any of this

# Block device access.
neverallow netd dev_type:blk_file { read write };

# ptrace any other app
neverallow netd { domain }:process ptrace;

# Write to /system.
neverallow netd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow netd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
# Network types
type node, node_type;
type netif, netif_type;
type port, port_type;

# Use network sockets.
allow netdomain self:tcp_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
allow netdomain self:{ udp_socket rawip_socket } { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
# Connect to ports.
allow netdomain port_type:tcp_socket name_connect;
# Bind to ports.
allow netdomain node_type:{ tcp_socket udp_socket } node_bind;
allow netdomain port_type:udp_socket name_bind;
allow netdomain port_type:tcp_socket name_bind;
# See changes to the routing table.
allow netdomain self:netlink_route_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_read };

# Talks to netd via dnsproxyd socket.



allow netdomain dnsproxyd_socket:sock_file write;
allow netdomain netd:unix_stream_socket connectto;



# Talks to netd via fwmarkd socket.



allow netdomain fwmarkd_socket:sock_file write;
allow netdomain netd:unix_stream_socket connectto;



# Connect to mdnsd via mdnsd socket.



allow netdomain mdnsd_socket:sock_file write;
allow netdomain mdnsd:unix_stream_socket connectto;


# nfc subsystem
type nfc, domain;

typeattribute nfc appdomain;
# Label ashmem objects with our own unique type.

type nfc_tmpfs, file_type;
type_transition nfc tmpfs:file nfc_tmpfs;
allow nfc nfc_tmpfs:file { read write };

# Map with PROT_EXEC.
allow nfc nfc_tmpfs:file execute;


typeattribute nfc netdomain;


typeattribute nfc binderservicedomain;


# Set NFC properties


allow nfc property_socket:sock_file write;
allow nfc init:unix_stream_socket connectto;

allow nfc nfc_prop:property_service set;


# NFC device access.
allow nfc nfc_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Data file accesses.
allow nfc nfc_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow nfc nfc_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

allow nfc sysfs_nfc_power_writable:file { { getattr open read ioctl lock } { open append write } };
allow nfc sysfs:file write;

allow nfc drmserver_service:service_manager find;
allow nfc mediaserver_service:service_manager find;
allow nfc nfc_service:service_manager { add find };
allow nfc radio_service:service_manager find;
allow nfc surfaceflinger_service:service_manager find;
allow nfc app_api_service:service_manager find;
allow nfc system_api_service:service_manager find;

# already open bugreport file descriptors may be shared with
# the nfc process, from a file in
# /data/data/com.android.shell/files/bugreports/bugreport-*.
allow nfc shell_data_file:file read;
# perfprofd - perf profile collection daemon
type perfprofd_exec, exec_type, file_type;


###
### Apps signed with the platform key.
###

type platform_app, domain;

typeattribute platform_app appdomain;
# Label ashmem objects with our own unique type.

type platform_app_tmpfs, file_type;
type_transition platform_app tmpfs:file platform_app_tmpfs;
allow platform_app platform_app_tmpfs:file { read write };

# Map with PROT_EXEC.
allow platform_app platform_app_tmpfs:file execute;

# Access the network.

typeattribute platform_app netdomain;

# Access bluetooth.

typeattribute platform_app bluetoothdomain;

# Read from /data/local/tmp or /data/data/com.android.shell.
allow platform_app shell_data_file:dir search;
allow platform_app shell_data_file:file { open getattr read };
# Populate /data/app/vmdl*.tmp, /data/app-private/vmdl*.tmp files
# created by system server.
allow platform_app { apk_tmp_file apk_private_tmp_file }:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow platform_app { apk_tmp_file apk_private_tmp_file }:file { { getattr open read ioctl lock } { open append write } };
allow platform_app apk_private_data_file:dir search;
# ASEC
allow platform_app asec_apk_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow platform_app asec_apk_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access to /data/media.
allow platform_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow platform_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Write to /cache.
allow platform_app cache_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow platform_app cache_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Direct access to vold-mounted storage under /mnt/media_rw
# This is a performance optimization that allows platform apps to bypass the FUSE layer
allow platform_app mnt_media_rw_file:dir { open getattr read search ioctl };
allow platform_app vfat:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow platform_app vfat:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

allow platform_app drmserver_service:service_manager find;
allow platform_app mediaserver_service:service_manager find;
allow platform_app persistent_data_block_service:service_manager find;
allow platform_app radio_service:service_manager find;
allow platform_app surfaceflinger_service:service_manager find;
allow platform_app app_api_service:service_manager find;
allow platform_app system_api_service:service_manager find;
# Point to Point Protocol daemon
type ppp, domain;
type ppp_device, dev_type;
type ppp_exec, exec_type, file_type;

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow mtp ppp_exec:file { getattr open read execute };
allow mtp ppp:process transition;
# New domain is entered by executing the file.
allow ppp ppp_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow ppp mtp:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit mtp ppp:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow mtp ppp:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition mtp ppp_exec:process ppp;



typeattribute ppp netdomain;


allow ppp mtp:socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow ppp mtp:unix_dgram_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow ppp ppp_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow ppp self:capability net_admin;
allow ppp system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# XXX Run toolbox.  Might not be needed.
allow ppp toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow ppp toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow ppp vpn_data_file:dir { open search write add_name remove_name };
allow ppp vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow ppp mtp:fd use;
###
### A domain for further sandboxing privileged apps.
###
type priv_app, domain;

typeattribute priv_app appdomain;
# Label ashmem objects with our own unique type.

type priv_app_tmpfs, file_type;
type_transition priv_app tmpfs:file priv_app_tmpfs;
allow priv_app priv_app_tmpfs:file { read write };

# Map with PROT_EXEC.
allow priv_app priv_app_tmpfs:file execute;

# Access the network.

typeattribute priv_app netdomain;

# Access bluetooth.

typeattribute priv_app bluetoothdomain;


# Some apps ship with shared libraries and binaries that they write out
# to their sandbox directory and then execute.
allow priv_app app_data_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# android.process.media uses /dev/mtp_usb
allow priv_app mtp_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Allow the allocation and use of ptys
# Used by: https://play.privileged.com/store/apps/details?id=jackpal.androidterm

# Each domain gets a unique devpts type.
type priv_app_devpts, fs_type;
# Label the pty with the unique type when created.
type_transition priv_app devpts:chr_file priv_app_devpts;
# Allow use of the pty after creation.
allow priv_app priv_app_devpts:chr_file { open getattr read write ioctl };
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
# allowed to everyone via domain.te.


allow priv_app drmserver_service:service_manager find;
allow priv_app mediaserver_service:service_manager find;
allow priv_app nfc_service:service_manager find;
allow priv_app radio_service:service_manager find;
allow priv_app surfaceflinger_service:service_manager find;
allow priv_app app_api_service:service_manager find;
allow priv_app system_api_service:service_manager find;
allow priv_app persistent_data_block_service:service_manager find;

# Traverse into /mnt/media_rw for bypassing FUSE daemon
# TODO: narrow this to just MediaProvider
allow priv_app mnt_media_rw_file:dir search;

# Write to /cache.
allow priv_app cache_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow priv_app cache_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access to /data/media.
allow priv_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow priv_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Used by Finsky / Android "Verify Apps" functionality when
# running "adb install foo.apk".
allow priv_app shell_data_file:file { getattr open read ioctl lock };
allow priv_app shell_data_file:dir { open getattr read search ioctl };

# Allow verifier to access staged apks.
allow priv_app { apk_tmp_file apk_private_tmp_file }:dir { open getattr read search ioctl };
allow priv_app { apk_tmp_file apk_private_tmp_file }:file { getattr open read ioctl lock };

# b/18504118: Allow reads from /data/anr/traces.txt
allow priv_app anr_data_file:file { getattr open read ioctl lock };

# Allow GMS core to access perfprofd output, which is stored
# in /data/misc/perfprofd/. GMS core will need to list all
# data stored in that directory to process them one by one.


###
### neverallow rules
###

# Receive or send uevent messages.
neverallow priv_app domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow priv_app domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow priv_app debugfs:file read;

# Do not allow privileged apps to register services.
# Only trusted components of Android should be registering
# services.
neverallow priv_app service_manager_type:service_manager add;

# Do not allow privileged apps to connect to the property service
# or set properties. b/10243159
neverallow priv_app property_socket:sock_file write;
neverallow priv_app init:unix_stream_socket connectto;
neverallow priv_app property_type:property_service set;

# Do not allow priv_app to be assigned mlstrustedsubject.
# This would undermine the per-user isolation model being
# enforced via levelFrom=user in seapp_contexts and the mls
# constraints.  As there is no direct way to specify a neverallow
# on attribute assignment, this relies on the fact that fork
# permission only makes sense within a domain (hence should
# never be granted to any other domain within mlstrustedsubject)
# and priv_app is allowed fork permission to itself.
neverallow priv_app mlstrustedsubject:process fork;

# Do not allow priv_app to hard link to any files.
# In particular, if priv_app links to other app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure priv_app never has this
# capability.
neverallow priv_app file_type:file link;
type default_prop, property_type;
type shell_prop, property_type;
type debug_prop, property_type;
type persist_debug_prop, property_type;
type debuggerd_prop, property_type;
type dhcp_prop, property_type;
type fingerprint_prop, property_type;
type ffs_prop, property_type;
type radio_prop, property_type;
type net_radio_prop, property_type;
type system_radio_prop, property_type;
type system_prop, property_type;
type vold_prop, property_type;
type ctl_bootanim_prop, property_type;
type ctl_default_prop, property_type;
type ctl_dhcp_pan_prop, property_type;
type ctl_dumpstate_prop, property_type;
type ctl_fuse_prop, property_type;
type ctl_mdnsd_prop, property_type;
type ctl_rildaemon_prop, property_type;
type ctl_bugreport_prop, property_type;
type ctl_console_prop, property_type;
type audio_prop, property_type;
type logd_prop, property_type;
type restorecon_prop, property_type;
type security_prop, property_type;
type bluetooth_prop, property_type;
type pan_result_prop, property_type;
type powerctl_prop, property_type;
type nfc_prop, property_type;
type dalvik_prop, property_type;
type config_prop, property_type;
# IKE key management daemon
type racoon, domain;
type racoon_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init racoon_exec:file { getattr open read execute };
allow init racoon:process transition;
# New domain is entered by executing the file.
allow racoon racoon_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow racoon init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init racoon:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init racoon:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init racoon_exec:process racoon;


type racoon_tmpfs, file_type;
type_transition racoon tmpfs:file racoon_tmpfs;
allow racoon racoon_tmpfs:file { read write };


typeattribute racoon mlstrustedsubject;


typeattribute racoon netdomain;



# Call the servicemanager and transfer references to it.
allow racoon servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager racoon:dir search;
allow servicemanager racoon:file { read open };
allow servicemanager racoon:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


allow racoon tun_device:chr_file { getattr open read ioctl lock };
allow racoon cgroup:dir { add_name create };
allow racoon kernel:system module_request;

allow racoon self:key_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:capability { net_admin net_bind_service net_raw setuid };

# XXX: should we give ip-up-vpn its own label (currently racoon domain)
allow racoon system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# XXX Run toolbox.  Might not be needed.
allow racoon toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow racoon toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow racoon vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow racoon vpn_data_file:dir { open search write add_name remove_name };


  allow keystore racoon:dir search;
  allow keystore racoon:file { read open };
  allow keystore racoon:process getattr;
  allow racoon keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow racoon keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore racoon:binder transfer;
# Receive and use open files from the server.
allow racoon keystore:fd use;



# Racoon (VPN) has a restricted set of permissions from the default.
allow racoon keystore:keystore_key {
	get
	sign
	verify
};
# phone subsystem
type radio, domain, mlstrustedsubject;

typeattribute radio appdomain;
# Label ashmem objects with our own unique type.

type radio_tmpfs, file_type;
type_transition radio tmpfs:file radio_tmpfs;
allow radio radio_tmpfs:file { read write };

# Map with PROT_EXEC.
allow radio radio_tmpfs:file execute;


typeattribute radio netdomain;


typeattribute radio bluetoothdomain;


typeattribute radio binderservicedomain;


# Talks to rild via the rild socket.



allow radio rild_socket:sock_file write;
allow radio rild:unix_stream_socket connectto;



# Data file accesses.
allow radio radio_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow radio radio_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

allow radio alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow radio net_data_file:dir search;
allow radio net_data_file:file { getattr open read ioctl lock };

# Property service


allow radio property_socket:sock_file write;
allow radio init:unix_stream_socket connectto;

allow radio radio_prop:property_service set;



allow radio property_socket:sock_file write;
allow radio init:unix_stream_socket connectto;

allow radio system_radio_prop:property_service set;



allow radio property_socket:sock_file write;
allow radio init:unix_stream_socket connectto;

allow radio net_radio_prop:property_service set;

auditallow radio net_radio_prop:property_service set;
auditallow radio system_radio_prop:property_service set;

# ctl interface


allow radio property_socket:sock_file write;
allow radio init:unix_stream_socket connectto;

allow radio ctl_rildaemon_prop:property_service set;


allow radio drmserver_service:service_manager find;
allow radio mediaserver_service:service_manager find;
allow radio radio_service:service_manager { add find };
allow radio surfaceflinger_service:service_manager find;
allow radio app_api_service:service_manager find;
allow radio system_api_service:service_manager find;
# recovery console (used in recovery init.rc for /sbin/recovery)

# Declare the domain unconditionally so we can always reference it
# in neverallow rules.
type recovery, domain;

# But the allow rules are only included in the recovery policy.
# Otherwise recovery is only allowed the domain rules.


###
### neverallow rules
###

# Recovery should never touch /data.
#
# In particular, if /data is encrypted, it is not accessible
# to recovery anyway.
#
# For now, we only enforce write/execute restrictions, as domain.te
# contains a number of read-only rules that apply to all
# domains, including recovery.
#
# TODO: tighten this up further.
neverallow recovery data_file_type:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };
neverallow recovery data_file_type:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };
# rild - radio interface layer daemon
type rild, domain;
type rild_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init rild_exec:file { getattr open read execute };
allow init rild:process transition;
# New domain is entered by executing the file.
allow rild rild_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow rild init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init rild:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init rild:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init rild_exec:process rild;


type rild_tmpfs, file_type;
type_transition rild tmpfs:file rild_tmpfs;
allow rild rild_tmpfs:file { read write };



typeattribute rild netdomain;

allow rild self:netlink_route_socket nlmsg_write;
allow rild kernel:system module_request;
allow rild self:capability { setuid net_admin net_raw };
allow rild alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow rild cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow rild radio_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow rild radio_device:blk_file { getattr open read ioctl lock };
allow rild mtd_device:dir search;
allow rild efs_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow rild efs_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow rild shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow rild bluetooth_efs_file:file { getattr open read ioctl lock };
allow rild bluetooth_efs_file:dir { open getattr read search ioctl };
allow rild radio_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow rild radio_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow rild sdcard_type:dir { open getattr read search ioctl };
allow rild system_data_file:dir { open getattr read search ioctl };
allow rild system_data_file:file { getattr open read ioctl lock };
allow rild system_file:file { getattr execute execute_no_trans };
# XXX Run toolbox.  Might not be needed.
allow rild toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow rild toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# property service


allow rild property_socket:sock_file write;
allow rild init:unix_stream_socket connectto;

allow rild radio_prop:property_service set;



allow rild property_socket:sock_file write;
allow rild init:unix_stream_socket connectto;

allow rild net_radio_prop:property_service set;



allow rild property_socket:sock_file write;
allow rild init:unix_stream_socket connectto;

allow rild system_radio_prop:property_service set;

auditallow rild net_radio_prop:property_service set;
auditallow rild system_radio_prop:property_service set;

# Read/Write to uart driver (for GPS)
allow rild gps_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow rild tty_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Allow rild to create and use netlink sockets.
allow rild self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow rild self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Access to wake locks

# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow rild sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow rild self:capability2 block_suspend;


allow rild self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
type runas, domain, mlstrustedsubject;
type runas_exec, exec_type, file_type;

# ndk-gdb invokes adb shell run-as.

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow shell runas_exec:file { getattr open read execute };
allow shell runas:process transition;
# New domain is entered by executing the file.
allow runas runas_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow runas shell:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit shell runas:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow shell runas:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition shell runas_exec:process runas;

allow runas adbd:process sigchld;
allow runas shell:fd use;
allow runas shell:fifo_file { read write };
allow runas devpts:chr_file { read write ioctl };
allow runas shell_data_file:file { read write };

# run-as reads package information.
allow runas system_data_file:file { getattr open read ioctl lock };

# run-as checks and changes to the app data dir.
dontaudit runas self:capability dac_override;
allow runas app_data_file:dir { getattr search };

# run-as switches to the app UID/GID.
allow runas self:capability { setuid setgid };

# run-as switches to the app security context.
# read /seapp_contexts and /data/security/seapp_contexts

allow runas security_file:dir { open getattr read search ioctl };
allow runas security_file:file { getattr open read ioctl lock };


allow runas selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow runas kernel:security check_context;
 # validate context
allow runas self:process setcurrent;
allow runas { appdomain -system_app }:process dyntransition; # setcon

###
### neverallow rules
###

# run-as cannot have capabilities other than CAP_SETUID and CAP_SETGID
neverallow runas self:capability ~{ setuid setgid };
neverallow runas self:capability2 *;
type sdcardd, domain;
type sdcardd_exec, exec_type, file_type;

allow sdcardd cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow sdcardd fuse_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow sdcardd rootfs:dir mounton;  # TODO: deprecated in M
allow sdcardd mnt_media_rw_file:dir { open getattr read search ioctl };
allow sdcardd storage_file:dir search;
allow sdcardd storage_stub_file:dir { search mounton };
allow sdcardd sdcard_type:filesystem { mount unmount };
allow sdcardd self:capability { setuid setgid dac_override sys_admin sys_resource };

allow sdcardd sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow sdcardd sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

type_transition sdcardd system_data_file:{ dir file } media_rw_data_file;
allow sdcardd media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow sdcardd media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Read /data/system/packages.list.
allow sdcardd system_data_file:file { getattr open read ioctl lock };

# Read /data/.layout_version
allow sdcardd install_data_file:file { getattr open read ioctl lock };

# Allow stdin/out back to vold
allow sdcardd vold:fd use;
allow sdcardd vold:fifo_file { read write getattr };

# Allow running on top of expanded storage
allow sdcardd mnt_expand_file:dir search;

###
### neverallow rules
###

# The sdcard daemon should no longer be started from init
neverallow init sdcardd_exec:file execute;
neverallow init sdcardd:process { transition dyntransition };
# servicemanager - the Binder context manager
type servicemanager, domain, mlstrustedsubject;
type servicemanager_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init servicemanager_exec:file { getattr open read execute };
allow init servicemanager:process transition;
# New domain is entered by executing the file.
allow servicemanager servicemanager_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow servicemanager init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init servicemanager:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init servicemanager:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init servicemanager_exec:process servicemanager;


type servicemanager_tmpfs, file_type;
type_transition servicemanager tmpfs:file servicemanager_tmpfs;
allow servicemanager servicemanager_tmpfs:file { read write };



# Note that we do not use the binder_* macros here.
# servicemanager is unique in that it only provides
# name service (aka context manager) for Binder.
# As such, it only ever receives and transfers other references
# created by other domains.  It never passes its own references
# or initiates a Binder IPC.
allow servicemanager self:binder set_context_mgr;
allow servicemanager { domain -init }:binder transfer;

# Check SELinux permissions.

allow servicemanager selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow servicemanager kernel:security compute_av;
allow servicemanager self:netlink_selinux_socket *;

type bluetooth_service,         service_manager_type;
type default_android_service,   service_manager_type;
type drmserver_service,         service_manager_type;
type gatekeeper_service,        app_api_service, service_manager_type;
type fingerprintd_service,      service_manager_type;
type healthd_service,           service_manager_type;
type inputflinger_service,      service_manager_type;
type keystore_service,          service_manager_type;
type mediaserver_service,       service_manager_type;
type nfc_service,               service_manager_type;
type radio_service,             service_manager_type;
type surfaceflinger_service,    service_manager_type;
type system_app_service,        service_manager_type;

# system_server_services broken down
type accessibility_service, app_api_service, system_server_service, service_manager_type;
type account_service, app_api_service, system_server_service, service_manager_type;
type activity_service, app_api_service, system_server_service, service_manager_type;
type alarm_service, app_api_service, system_server_service, service_manager_type;
type appops_service, app_api_service, system_server_service, service_manager_type;
type appwidget_service, app_api_service, system_server_service, service_manager_type;
type assetatlas_service, app_api_service, system_server_service, service_manager_type;
type audio_service, app_api_service, system_server_service, service_manager_type;
type backup_service, app_api_service, system_server_service, service_manager_type;
type batterystats_service, app_api_service, system_server_service, service_manager_type;
type battery_service, system_server_service, service_manager_type;
type bluetooth_manager_service, app_api_service, system_server_service, service_manager_type;
type cameraproxy_service, system_server_service, service_manager_type;
type clipboard_service, app_api_service, system_server_service, service_manager_type;
type IProxyService_service, system_api_service, system_server_service, service_manager_type;
type commontime_management_service, system_server_service, service_manager_type;
type connectivity_service, app_api_service, system_server_service, service_manager_type;
type consumer_ir_service, app_api_service, system_server_service, service_manager_type;
type content_service, app_api_service, system_server_service, service_manager_type;
type country_detector_service, system_api_service, system_server_service, service_manager_type;
type cpuinfo_service, system_api_service, system_server_service, service_manager_type;
type dbinfo_service, system_api_service, system_server_service, service_manager_type;
type device_policy_service, app_api_service, system_server_service, service_manager_type;
type deviceidle_service, system_api_service, system_server_service, service_manager_type;
type devicestoragemonitor_service, system_server_service, service_manager_type;
type diskstats_service, system_api_service, system_server_service, service_manager_type;
type display_service, app_api_service, system_server_service, service_manager_type;
type DockObserver_service, system_server_service, service_manager_type;
type dreams_service, system_api_service, system_server_service, service_manager_type;
type dropbox_service, app_api_service, system_server_service, service_manager_type;
type ethernet_service, app_api_service, system_server_service, service_manager_type;
type fingerprint_service, app_api_service, system_server_service, service_manager_type;
type gfxinfo_service, system_api_service, system_server_service, service_manager_type;
type graphicsstats_service, app_api_service, system_server_service, service_manager_type;
type hardware_service, system_server_service, service_manager_type;
type hdmi_control_service, system_api_service, system_server_service, service_manager_type;
type input_method_service, app_api_service, system_server_service, service_manager_type;
type input_service, app_api_service, system_server_service, service_manager_type;
type imms_service, app_api_service, system_server_service, service_manager_type;
type jobscheduler_service, app_api_service, system_server_service, service_manager_type;
type launcherapps_service, app_api_service, system_server_service, service_manager_type;
type location_service, app_api_service, system_server_service, service_manager_type;
type lock_settings_service, system_api_service, system_server_service, service_manager_type;
type media_projection_service, app_api_service, system_server_service, service_manager_type;
type media_router_service, app_api_service, system_server_service, service_manager_type;
type media_session_service, app_api_service, system_server_service, service_manager_type;
type meminfo_service, system_api_service, system_server_service, service_manager_type;
type midi_service, app_api_service, system_server_service, service_manager_type;
type mount_service, app_api_service, system_server_service, service_manager_type;
type netpolicy_service, app_api_service, system_server_service, service_manager_type;
type netstats_service, app_api_service, system_server_service, service_manager_type;
type network_management_service, app_api_service, system_server_service, service_manager_type;
type network_score_service, system_api_service, system_server_service, service_manager_type;
type notification_service, app_api_service, system_server_service, service_manager_type;
type package_service, app_api_service, system_server_service, service_manager_type;
type permission_service, app_api_service, system_server_service, service_manager_type;
type persistent_data_block_service, system_api_service, system_server_service, service_manager_type;
type power_service, app_api_service, system_server_service, service_manager_type;
type print_service, app_api_service, system_server_service, service_manager_type;
type processinfo_service, system_server_service, service_manager_type;
type procstats_service, app_api_service, system_server_service, service_manager_type;
type registry_service, app_api_service, system_server_service, service_manager_type;
type restrictions_service, app_api_service, system_server_service, service_manager_type;
type rttmanager_service, app_api_service, system_server_service, service_manager_type;
type samplingprofiler_service, system_server_service, service_manager_type;
type scheduling_policy_service, system_server_service, service_manager_type;
type search_service, app_api_service, system_server_service, service_manager_type;
type sensorservice_service, app_api_service, system_server_service, service_manager_type;
type serial_service, system_api_service, system_server_service, service_manager_type;
type servicediscovery_service, app_api_service, system_server_service, service_manager_type;
type statusbar_service, app_api_service, system_server_service, service_manager_type;
type task_service, system_server_service, service_manager_type;
type textservices_service, app_api_service, system_server_service, service_manager_type;
type telecom_service, app_api_service, system_server_service, service_manager_type;
type trust_service, app_api_service, system_server_service, service_manager_type;
type tv_input_service, app_api_service, system_server_service, service_manager_type;
type uimode_service, app_api_service, system_server_service, service_manager_type;
type updatelock_service, system_api_service, system_server_service, service_manager_type;
type usagestats_service, app_api_service, system_server_service, service_manager_type;
type usb_service, app_api_service, system_server_service, service_manager_type;
type user_service, app_api_service, system_server_service, service_manager_type;
type vibrator_service, app_api_service, system_server_service, service_manager_type;
type voiceinteraction_service, app_api_service, system_server_service, service_manager_type;
type wallpaper_service, app_api_service, system_server_service, service_manager_type;
type webviewupdate_service, app_api_service, system_server_service, service_manager_type;
type wifip2p_service, app_api_service, system_server_service, service_manager_type;
type wifiscanner_service, system_api_service, system_server_service, service_manager_type;
type wifi_service, app_api_service, system_server_service, service_manager_type;
type window_service, system_api_service, system_server_service, service_manager_type;
# sgdisk called from vold
type sgdisk, domain;
type sgdisk_exec, exec_type, file_type;

# Allowed to read/write low-level partition tables
allow sgdisk block_device:dir search;
allow sgdisk vold_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Inherit and use pty created by android_fork_execvp()
allow sgdisk devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow sgdisk vold:fd use;
allow sgdisk vold:fifo_file { read write getattr };

# Used to probe kernel to reload partition tables
allow sgdisk self:capability sys_admin;

# Only allow entry from vold
neverallow { domain -vold } sgdisk:process transition;
neverallow domain sgdisk:process dyntransition;
neverallow sgdisk { file_type fs_type -sgdisk_exec }:file entrypoint;
# Process which creates/updates shared RELRO files to be used by other apps.
type shared_relro, domain;

# The shared relro process is a Java program forked from the zygote, so it
# inherits from app to get basic permissions it needs to run.

typeattribute shared_relro appdomain;
# Label ashmem objects with our own unique type.

type shared_relro_tmpfs, file_type;
type_transition shared_relro tmpfs:file shared_relro_tmpfs;
allow shared_relro shared_relro_tmpfs:file { read write };

# Map with PROT_EXEC.
allow shared_relro shared_relro_tmpfs:file execute;


# Grant write access to the shared relro files/directory.
allow shared_relro shared_relro_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow shared_relro shared_relro_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Needs to contact the "webviewupdate" and "activity" services
allow shared_relro webviewupdate_service:service_manager find;
# Domain for shell processes spawned by ADB or console service.
type shell, domain, mlstrustedsubject;
type shell_exec, exec_type, file_type;

# Create and use network sockets.

typeattribute shell netdomain;


# Run app_process.
# XXX Transition into its own domain?

typeattribute shell appdomain;
# Label ashmem objects with our own unique type.

type shell_tmpfs, file_type;
type_transition shell tmpfs:file shell_tmpfs;
allow shell shell_tmpfs:file { read write };

# Map with PROT_EXEC.
allow shell shell_tmpfs:file execute;


# logcat

allow shell logcat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



allow shell logdr_socket:sock_file write;
allow shell logd:unix_stream_socket connectto;




# Group AID_LOG checked by filesystem & logd
# to permit control commands



allow shell logd_socket:sock_file write;
allow shell logd:unix_stream_socket connectto;



# logcat -L (directly, or via dumpstate)
allow shell pstorefs:dir search;
allow shell pstorefs:file { getattr open read ioctl lock };
# logpersistd (nee logcatd) files


# read files in /data/anr
allow shell anr_data_file:dir { open getattr read search ioctl };
allow shell anr_data_file:file { getattr open read ioctl lock };

# Access /data/local/tmp.
allow shell shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow shell shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow shell shell_data_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow shell shell_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Read/execute files in /data/nativetest


# adb bugreport



allow shell dumpstate_socket:sock_file write;
allow shell dumpstate:unix_stream_socket connectto;



allow shell devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell console_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell input_device:dir { open getattr read search ioctl };
allow shell input_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell system_file:file { getattr execute execute_no_trans };
allow shell toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow shell shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow shell zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };


allow shell apk_data_file:dir { open getattr read search ioctl };
allow shell apk_data_file:{ file lnk_file } { getattr open read ioctl lock };


# Set properties.


allow shell property_socket:sock_file write;
allow shell init:unix_stream_socket connectto;

allow shell shell_prop:property_service set;



allow shell property_socket:sock_file write;
allow shell init:unix_stream_socket connectto;

allow shell ctl_dumpstate_prop:property_service set;



allow shell property_socket:sock_file write;
allow shell init:unix_stream_socket connectto;

allow shell debug_prop:property_service set;



allow shell property_socket:sock_file write;
allow shell init:unix_stream_socket connectto;

allow shell powerctl_prop:property_service set;


# systrace support - allow atrace to run
# debugfs doesn't support labeling individual files, so we have
# to grant read access to all of /sys/kernel/debug.
# Directory read access and file write access is already granted
# in domain.te.
allow shell debugfs:file { getattr open read ioctl lock };
allow shell atrace_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



# allow shell to run dmesg
allow shell kernel:system syslog_read;

# allow shell access to services
allow shell servicemanager:service_manager list;
# don't allow shell to access GateKeeper service
allow shell { service_manager_type -gatekeeper_service }:service_manager find;

# allow shell to look through /proc/ for ps, top
allow shell domain:dir { search open read getattr };
allow shell domain:{ file lnk_file } { open read getattr };

# allow shell to read /proc/pid/attr/current for ps -Z
allow shell domain:process getattr;

# enable shell domain to read/write files/dirs for bootchart data
# User will creates the start and stop file via adb shell
# and read other files created by init process under /data/bootchart
allow shell bootchart_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow shell bootchart_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Make sure strace works for the non-privileged shell user
allow shell self:process ptrace;

# Do not allow shell to hard link to any files.
# In particular, if shell hard links to app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure the shell user never has this
# capability.
neverallow shell file_type:file link;
# slideshow seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type slideshow, domain;

allow slideshow kmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow slideshow sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow slideshow self:capability2 block_suspend;

allow slideshow device:dir { open getattr read search ioctl };
allow slideshow self:capability sys_tty_config;
allow slideshow graphics_device:dir { open getattr read search ioctl };
allow slideshow graphics_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow slideshow input_device:dir { open getattr read search ioctl };
allow slideshow input_device:chr_file { getattr open read ioctl lock };
allow slideshow tty_device:chr_file { { getattr open read ioctl lock } { open append write } };

# surfaceflinger - display compositor service
type surfaceflinger, domain;
type surfaceflinger_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init surfaceflinger_exec:file { getattr open read execute };
allow init surfaceflinger:process transition;
# New domain is entered by executing the file.
allow surfaceflinger surfaceflinger_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow surfaceflinger init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init surfaceflinger:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init surfaceflinger:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init surfaceflinger_exec:process surfaceflinger;


type surfaceflinger_tmpfs, file_type;
type_transition surfaceflinger tmpfs:file surfaceflinger_tmpfs;
allow surfaceflinger surfaceflinger_tmpfs:file { read write };


typeattribute surfaceflinger mlstrustedsubject;

# Perform Binder IPC.

# Call the servicemanager and transfer references to it.
allow surfaceflinger servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager surfaceflinger:dir search;
allow servicemanager surfaceflinger:file { read open };
allow servicemanager surfaceflinger:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow surfaceflinger binderservicedomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow binderservicedomain surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger binderservicedomain:fd use;


# Call the server domain and optionally transfer references to it.
allow surfaceflinger appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger appdomain:fd use;


# Call the server domain and optionally transfer references to it.
allow surfaceflinger bootanim:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow bootanim surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger bootanim:fd use;


typeattribute surfaceflinger binderservicedomain;


# Binder IPC to bu, presently runs in adbd domain.

# Call the server domain and optionally transfer references to it.
allow surfaceflinger adbd:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow adbd surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger adbd:fd use;


# Read /proc/pid files for Binder clients.

allow surfaceflinger binderservicedomain:dir { open getattr read search ioctl };
allow surfaceflinger binderservicedomain:{ file lnk_file } { getattr open read ioctl lock };


allow surfaceflinger appdomain:dir { open getattr read search ioctl };
allow surfaceflinger appdomain:{ file lnk_file } { getattr open read ioctl lock };


# Access the GPU.
allow surfaceflinger gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /dev/graphics/fb0.
allow surfaceflinger graphics_device:dir search;
allow surfaceflinger graphics_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /dev/video1.
allow surfaceflinger video_device:dir { open getattr read search ioctl };
allow surfaceflinger video_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Create and use netlink kobject uevent sockets.
allow surfaceflinger self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set properties.


allow surfaceflinger property_socket:sock_file write;
allow surfaceflinger init:unix_stream_socket connectto;

allow surfaceflinger system_prop:property_service set;



allow surfaceflinger property_socket:sock_file write;
allow surfaceflinger init:unix_stream_socket connectto;

allow surfaceflinger ctl_bootanim_prop:property_service set;


# Use open files supplied by an app.
allow surfaceflinger appdomain:fd use;
allow surfaceflinger app_data_file:file { read write };

# Use open file provided by bootanim.
allow surfaceflinger bootanim:fd use;

# Allow a dumpstate triggered screenshot

# Call the server domain and optionally transfer references to it.
allow surfaceflinger dumpstate:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow dumpstate surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger dumpstate:fd use;


# Call the server domain and optionally transfer references to it.
allow surfaceflinger shell:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow shell surfaceflinger:binder transfer;
# Receive and use open files from the server.
allow surfaceflinger shell:fd use;


allow surfaceflinger dumpstate:dir { open getattr read search ioctl };
allow surfaceflinger dumpstate:{ file lnk_file } { getattr open read ioctl lock };


# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.
allow surfaceflinger tee:unix_stream_socket connectto;
allow surfaceflinger tee_device:chr_file { { getattr open read ioctl lock } { open append write } };


# media.player service
allow surfaceflinger mediaserver_service:service_manager find;
allow surfaceflinger permission_service:service_manager find;
allow surfaceflinger power_service:service_manager find;
allow surfaceflinger surfaceflinger_service:service_manager { add find };
allow surfaceflinger window_service:service_manager find;

###
### Neverallow rules
###
### surfaceflinger should NEVER do any of this

# Do not allow accessing SDcard files as unsafe ejection could
# cause the kernel to kill the process.
neverallow surfaceflinger sdcard_type:file { { getattr open read ioctl lock } { open append write } };
# File types must be defined for file_contexts.
type su_exec, exec_type, file_type;


#
# Apps that run with the system UID, e.g. com.android.system.ui,
# com.android.settings.  These are not as privileged as the system
# server.
#
type system_app, domain;

typeattribute system_app appdomain;
# Label ashmem objects with our own unique type.

type system_app_tmpfs, file_type;
type_transition system_app tmpfs:file system_app_tmpfs;
allow system_app system_app_tmpfs:file { read write };

# Map with PROT_EXEC.
allow system_app system_app_tmpfs:file execute;


typeattribute system_app netdomain;


typeattribute system_app binderservicedomain;


# Read and write /data/data subdirectory.
allow system_app system_app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_app system_app_data_file:{ file lnk_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Read /data/misc/keychain subdirectory.
allow system_app keychain_data_file:dir { open getattr read search ioctl };
allow system_app keychain_data_file:file { getattr open read ioctl lock };

# Read and write to other system-owned /data directories, such as
# /data/system/cache and /data/misc/user.
allow system_app system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_app system_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow system_app misc_user_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_app misc_user_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Audit writes to these directories and files so we can identify
# and possibly move these directories into their own type in the future.
auditallow system_app system_data_file:dir { create setattr add_name remove_name rmdir rename };
auditallow system_app system_data_file:file { create setattr append write link unlink rename };

# Access to vold-mounted storage for measuring free space
allow system_app mnt_media_rw_file:dir search;

# Read wallpaper file.
allow system_app wallpaper_file:file { getattr open read ioctl lock };

# Write to properties


allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app debug_prop:property_service set;



allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app system_prop:property_service set;



allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app ctl_bugreport_prop:property_service set;



allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app logd_prop:property_service set;



allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app net_radio_prop:property_service set;



allow system_app property_socket:sock_file write;
allow system_app init:unix_stream_socket connectto;

allow system_app system_radio_prop:property_service set;

auditallow system_app net_radio_prop:property_service set;
auditallow system_app system_radio_prop:property_service set;

# Create /data/anr/traces.txt.
allow system_app anr_data_file:dir { { open getattr read search ioctl } add_name write };
allow system_app anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Settings need to access app name and icon from asec
allow system_app asec_apk_file:file { getattr open read ioctl lock };

allow system_app servicemanager:service_manager list;
allow system_app service_manager_type:service_manager find;

allow system_app keystore:keystore_key {
	get_state
	get
	insert
	delete
	exist
	list
	reset
	password
	lock
	unlock
	is_empty
	sign
	verify
	grant
	duplicate
	clear_uid
	user_changed
};


# Group AID_LOG checked by filesystem & logd
# to permit control commands



allow system_app logd_socket:sock_file write;
allow system_app logd:unix_stream_socket connectto;



#
# System Server aka system_server spawned by zygote.
# Most of the framework services run in this process.
#
type system_server, domain, mlstrustedsubject;

# Define a type for tmpfs-backed ashmem regions.

type system_server_tmpfs, file_type;
type_transition system_server tmpfs:file system_server_tmpfs;
allow system_server system_server_tmpfs:file { read write };


# For art.
allow system_server dalvikcache_data_file:file execute;
allow system_server dalvikcache_data_file:dir { open getattr read search ioctl };

# /data/resource-cache
allow system_server resourcecache_data_file:file { getattr open read ioctl lock };
allow system_server resourcecache_data_file:dir { open getattr read search ioctl };

# ptrace to processes in the same domain for debugging crashes.
allow system_server self:process ptrace;

# Child of the zygote.
allow system_server zygote:fd use;
allow system_server zygote:process sigchld;
allow system_server zygote_tmpfs:file read;

# May kill zygote on crashes.
allow system_server zygote:process sigkill;

# Read /system/bin/app_process.
allow system_server zygote_exec:file { getattr open read ioctl lock };

# Needed to close the zygote socket, which involves getopt / getattr
allow system_server zygote:unix_stream_socket { getopt getattr };

# system server gets network and bluetooth permissions.

typeattribute system_server netdomain;


typeattribute system_server bluetoothdomain;


# These are the capabilities assigned by the zygote to the
# system server.
allow system_server self:capability {
    kill
    net_admin
    net_bind_service
    net_broadcast
    net_raw
    sys_boot
    sys_nice
    sys_resource
    sys_time
    sys_tty_config
};


# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow system_server sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow system_server self:capability2 block_suspend;


# Triggered by /proc/pid accesses, not allowed.
dontaudit system_server self:capability sys_ptrace;

# Trigger module auto-load.
allow system_server kernel:system module_request;

# Use netlink uevent sockets.
allow system_server self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Use generic netlink sockets.
allow system_server self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set and get routes directly via netlink.
allow system_server self:netlink_route_socket nlmsg_write;

# Kill apps.
allow system_server appdomain:process { sigkill signal };

# Set scheduling info for apps.
allow system_server appdomain:process { getsched setsched };
allow system_server mediaserver:process { getsched setsched };

# Read /proc/pid data for all domains. This is used by ProcessCpuTracker
# within system_server to keep track of memory and CPU usage for
# all processes on the device.

allow system_server domain:dir { open getattr read search ioctl };
allow system_server domain:{ file lnk_file } { getattr open read ioctl lock };


# Read/Write to /proc/net/xt_qtaguid/ctrl and and /dev/xt_qtaguid.
allow system_server qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
allow system_server qtaguid_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read /proc/uid_cputime/show_uid_stat.
allow system_server proc_uid_cputime_showstat:file { getattr open read ioctl lock };

# Write /proc/uid_cputime/remove_uid_range.
allow system_server proc_uid_cputime_removeuid:file { { open append write } getattr };

# Write to /proc/sysrq-trigger.
allow system_server proc_sysrq:file { { getattr open read ioctl lock } { open append write } };

# Read /sys/kernel/debug/wakeup_sources.
allow system_server debugfs:file { getattr open read ioctl lock };

# The DhcpClient and WifiWatchdog use packet_sockets
allow system_server self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# NetworkDiagnostics requires explicit bind() calls to ping sockets. These aren't actually the same
# as raw sockets, but the kernel doesn't yet distinguish between the two.
allow system_server node:rawip_socket node_bind;

# 3rd party VPN clients require a tun_socket to be created
allow system_server self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Notify init of death.
allow system_server init:process sigchld;

# Talk to init and various daemons via sockets.



allow system_server installd_socket:sock_file write;
allow system_server installd:unix_stream_socket connectto;





allow system_server lmkd_socket:sock_file write;
allow system_server lmkd:unix_stream_socket connectto;





allow system_server mtpd_socket:sock_file write;
allow system_server mtp:unix_stream_socket connectto;





allow system_server netd_socket:sock_file write;
allow system_server netd:unix_stream_socket connectto;





allow system_server vold_socket:sock_file write;
allow system_server vold:unix_stream_socket connectto;





allow system_server zygote_socket:sock_file write;
allow system_server zygote:unix_stream_socket connectto;





allow system_server gps_socket:sock_file write;
allow system_server gpsd:unix_stream_socket connectto;





allow system_server racoon_socket:sock_file write;
allow system_server racoon:unix_stream_socket connectto;



allow system_server wpa_socket:sock_file write;
allow system_server wpa:unix_dgram_socket sendto;


# Communicate over a socket created by surfaceflinger.
allow system_server surfaceflinger:unix_stream_socket { read write setopt };

# Perform Binder IPC.

# Call the servicemanager and transfer references to it.
allow system_server servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager system_server:dir search;
allow servicemanager system_server:file { read open };
allow servicemanager system_server:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow system_server binderservicedomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow binderservicedomain system_server:binder transfer;
# Receive and use open files from the server.
allow system_server binderservicedomain:fd use;


# Call the server domain and optionally transfer references to it.
allow system_server gatekeeperd:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow gatekeeperd system_server:binder transfer;
# Receive and use open files from the server.
allow system_server gatekeeperd:fd use;


# Call the server domain and optionally transfer references to it.
allow system_server fingerprintd:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow fingerprintd system_server:binder transfer;
# Receive and use open files from the server.
allow system_server fingerprintd:fd use;


# Call the server domain and optionally transfer references to it.
allow system_server appdomain:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow appdomain system_server:binder transfer;
# Receive and use open files from the server.
allow system_server appdomain:fd use;


# Call the server domain and optionally transfer references to it.
allow system_server dumpstate:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow dumpstate system_server:binder transfer;
# Receive and use open files from the server.
allow system_server dumpstate:fd use;


typeattribute system_server binderservicedomain;


# Ask debuggerd to dump backtraces for native stacks of interest.
allow system_server { mediaserver sdcardd surfaceflinger inputflinger }:debuggerd dump_backtrace;

# Read /proc/pid files for dumping stack traces of native processes.

allow system_server mediaserver:dir { open getattr read search ioctl };
allow system_server mediaserver:{ file lnk_file } { getattr open read ioctl lock };


allow system_server sdcardd:dir { open getattr read search ioctl };
allow system_server sdcardd:{ file lnk_file } { getattr open read ioctl lock };


allow system_server surfaceflinger:dir { open getattr read search ioctl };
allow system_server surfaceflinger:{ file lnk_file } { getattr open read ioctl lock };


allow system_server inputflinger:dir { open getattr read search ioctl };
allow system_server inputflinger:{ file lnk_file } { getattr open read ioctl lock };


# Use sockets received over binder from various services.
allow system_server mediaserver:tcp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server mediaserver:udp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };

# Check SELinux permissions.

allow system_server selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow system_server kernel:security compute_av;
allow system_server self:netlink_selinux_socket *;


# XXX Label sysfs files with a specific type?
allow system_server sysfs:file { { getattr open read ioctl lock } { open append write } };
allow system_server sysfs_nfc_power_writable:file { { getattr open read ioctl lock } { open append write } };
allow system_server sysfs_devices_system_cpu:file { open append write };
allow system_server sysfs_mac_address:file { getattr open read ioctl lock };

# Access devices.
allow system_server device:dir { open getattr read search ioctl };
allow system_server mdns_socket:sock_file { { getattr open read ioctl lock } { open append write } };
allow system_server alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server iio_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server input_device:dir { open getattr read search ioctl };
allow system_server input_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server radio_device:chr_file { getattr open read ioctl lock };
allow system_server tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server usbaccessory_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server video_device:dir { open getattr read search ioctl };
allow system_server video_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server adbd_socket:sock_file { { getattr open read ioctl lock } { open append write } };
allow system_server rtc_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server audio_device:dir { open getattr read search ioctl };

# write access needed for MIDI
allow system_server audio_device:chr_file { { getattr open read ioctl lock } { open append write } };

# tun device used for 3rd party vpn apps
allow system_server tun_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Manage system data files.
allow system_server system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server system_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow system_server keychain_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server keychain_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/app.
allow system_server apk_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server apk_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } link };
allow system_server apk_tmp_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server apk_tmp_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/app-private.
allow system_server apk_private_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server apk_private_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow system_server apk_private_tmp_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server apk_private_tmp_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage files within asec containers.
allow system_server asec_apk_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server asec_apk_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow system_server asec_public_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/anr.
allow system_server anr_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/backup.
allow system_server backup_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server backup_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Read from /data/dalvik-cache/profiles
allow system_server dalvikcache_profiles_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server dalvikcache_profiles_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Write to /data/system/heapdump
allow system_server heapdump_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server heapdump_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/misc/adb.
allow system_server adb_keys_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server adb_keys_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/misc/sms.
# TODO:  Split into a separate type?
allow system_server radio_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server radio_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/misc/systemkeys.
allow system_server systemkeys_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server systemkeys_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access /data/tombstones.
allow system_server tombstone_data_file:dir { open getattr read search ioctl };
allow system_server tombstone_data_file:file { getattr open read ioctl lock };

# Manage /data/misc/vpn.
allow system_server vpn_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/misc/wifi.
allow system_server wifi_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage /data/misc/zoneinfo.
allow system_server zoneinfo_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server zoneinfo_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Walk /data/data subdirectories.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:dir { getattr read search };
# Also permit for unlabeled /data/data subdirectories and
# for unlabeled asec containers on upgrades from 4.2.
allow system_server unlabeled:dir { open getattr read search ioctl };
# Read pkg.apk file before it has been relabeled by vold.
allow system_server unlabeled:file { getattr open read ioctl lock };

# Populate com.android.providers.settings/databases/settings.db.
allow system_server system_app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow system_server system_app_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Receive and use open app data files passed over binder IPC.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:file { getattr read write };

# Receive and use open /data/media files passed over binder IPC.
allow system_server media_rw_data_file:file { getattr read write };

# Read /file_contexts and /data/security/file_contexts

allow system_server security_file:dir { open getattr read search ioctl };
allow system_server security_file:file { getattr open read ioctl lock };


# Relabel apk files.
allow system_server { apk_tmp_file apk_private_tmp_file }:{ dir file } { relabelfrom relabelto };
allow system_server { apk_data_file apk_private_data_file }:{ dir file } { relabelfrom relabelto };

# Relabel wallpaper.
allow system_server system_data_file:file relabelfrom;
allow system_server wallpaper_file:file relabelto;
allow system_server wallpaper_file:file { { { getattr open read ioctl lock } { open append write } } unlink };

# This was originally required for relabeling /data/anr,
# but should not be used anymore. TODO: remove it.
allow system_server system_data_file:dir relabelfrom;
auditallow system_server system_data_file:dir relabelfrom;

# Property Service write


allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server system_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server dhcp_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server net_radio_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server system_radio_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server debug_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server powerctl_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server fingerprint_prop:property_service set;


# ctl interface


allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server ctl_default_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server ctl_dhcp_pan_prop:property_service set;



allow system_server property_socket:sock_file write;
allow system_server init:unix_stream_socket connectto;

allow system_server ctl_bugreport_prop:property_service set;


# Create a socket for receiving info from wpa.
type_transition system_server wifi_data_file:sock_file system_wpa_socket;
type_transition system_server wpa_socket:sock_file system_wpa_socket;
allow system_server wpa_socket:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server system_wpa_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Remove sockets created by wpa_supplicant
allow system_server wpa_socket:sock_file unlink;

# Create a socket for connections from debuggerd.
type_transition system_server system_data_file:sock_file system_ndebug_socket "ndebugsocket";
allow system_server system_ndebug_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Manage cache files.
allow system_server cache_file:dir { relabelfrom { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } };
allow system_server cache_file:file { relabelfrom { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } };
allow system_server cache_file:fifo_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Run system programs, e.g. dexopt.
allow system_server system_file:file { getattr execute execute_no_trans };

# XXX Run toolbox.  Might not be needed.
allow system_server toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow system_server toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# LocationManager(e.g, GPS) needs to read and write
# to uart driver and ctrl proc entry
allow system_server gps_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server gps_control:file { { getattr open read ioctl lock } { open append write } };

# Allow system_server to use app-created sockets and pipes.
allow system_server appdomain:{ tcp_socket udp_socket } { getattr getopt setopt read write shutdown };
allow system_server appdomain:{ fifo_file unix_stream_socket } { getattr read write };

# Allow abstract socket connection
allow system_server rild:unix_stream_socket connectto;

# BackupManagerService lets PMS create a data backup file
allow system_server cache_backup_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Relabel /data/backup
allow system_server backup_data_file:dir { relabelto relabelfrom };
# Relabel /cache/.*\.{data|restore}
allow system_server cache_backup_file:file { relabelto relabelfrom };
# LocalTransport creates and relabels /cache/backup
allow system_server cache_backup_file:dir { relabelto relabelfrom { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } };

# Allow system to talk to usb device
allow system_server usb_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server usb_device:dir { open getattr read search ioctl };

# Allow system to talk to sensors
allow system_server sensors_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read from HW RNG (needed by EntropyMixer).
allow system_server hw_random_device:chr_file { getattr open read ioctl lock };

# Read and delete files under /dev/fscklogs.

allow system_server fscklogs:dir { open getattr read search ioctl };
allow system_server fscklogs:{ file lnk_file } { getattr open read ioctl lock };

allow system_server fscklogs:dir { write remove_name };
allow system_server fscklogs:file unlink;

# logd access, system_server inherit logd write socket
# (urge is to deprecate this long term)
allow system_server zygote:unix_dgram_socket write;

# Read from log daemon.

allow system_server logcat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };



allow system_server logdr_socket:sock_file write;
allow system_server logd:unix_stream_socket connectto;




# Be consistent with DAC permissions. Allow system_server to write to
# /sys/module/lowmemorykiller/parameters/adj
# /sys/module/lowmemorykiller/parameters/minfree
allow system_server sysfs_lowmemorykiller:file { getattr { open append write } };

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow system_server pstorefs:dir { open getattr read search ioctl };
allow system_server pstorefs:file { getattr open read ioctl lock };

allow system_server drmserver_service:service_manager find;
allow system_server healthd_service:service_manager find;
allow system_server keystore_service:service_manager find;
allow system_server gatekeeper_service:service_manager find;
allow system_server fingerprintd_service:service_manager find;
allow system_server mediaserver_service:service_manager find;
allow system_server nfc_service:service_manager find;
allow system_server radio_service:service_manager find;
allow system_server system_server_service:service_manager { add find };
allow system_server surfaceflinger_service:service_manager find;

allow system_server keystore:keystore_key {
	get_state
	get
	insert
	delete
	exist
	list
	reset
	password
	lock
	unlock
	is_empty
	sign
	verify
	grant
	duplicate
	clear_uid
	add_auth
	user_changed
};

# Allow system server to search and write to the persistent factory reset
# protection partition. This block device does not get wiped in a factory reset.
allow system_server block_device:dir search;
allow system_server frp_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Clean up old cgroups
allow system_server cgroup:dir { remove_name rmdir };

# /oem access

allow system_server oemfs:dir { open getattr read search ioctl };
allow system_server oemfs:{ file lnk_file } { getattr open read ioctl lock };


# Allow resolving per-user storage symlinks
allow system_server { mnt_user_file storage_file }:dir { getattr search };
allow system_server { mnt_user_file storage_file }:lnk_file { getattr read };

# Allow statfs() on storage devices, which happens fast enough that
# we shouldn't be killed during unsafe removal
allow system_server sdcard_type:dir { getattr search };

# Traverse into expanded storage
allow system_server mnt_expand_file:dir { open getattr read search ioctl };

# Allow system process to relabel the fingerprint directory after mkdir
allow system_server fingerprintd_data_file:dir {{ open getattr read search ioctl } relabelto};

###
### Neverallow rules
###
### system_server should NEVER do any of this

# Do not allow opening files from external storage as unsafe ejection
# could cause the kernel to kill the system_server.
neverallow system_server sdcard_type:dir { open read write };
neverallow system_server sdcard_type:file { { getattr open read ioctl lock } { open append write } };

# system server should never be opening zygote spawned app data
# files directly. Rather, they should always be passed via a
# file descriptor.
# Types extracted from seapp_contexts type= fields, excluding
# those types that system_server needs to open directly.
neverallow system_server { bluetooth_data_file nfc_data_file shell_data_file app_data_file }:file open;

# system_server should never be executing dex2oat. This is either
# a bug (for example, bug 16317188), or represents an attempt by
# system server to dynamically load a dex file, something we do not
# want to allow.
neverallow system_server dex2oat_exec:file { execute execute_no_trans };

# system_server should never execute anything from /data except for /data/dalvik-cache files.
neverallow system_server {
  data_file_type
  -dalvikcache_data_file #mapping with PROT_EXEC
}:file { execute execute_no_trans };

# The only block device system_server should be accessing is
# the frp_block_device. This helps avoid a system_server to root
# escalation by writing to raw block devices.
neverallow system_server { dev_type -frp_block_device }:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# system_server should never use JIT functionality
neverallow system_server self:process execmem;
neverallow system_server ashmem_device:chr_file execute;
neverallow system_server system_server_tmpfs:file execute;
##
# trusted execution environment (tee) daemon
#
type tee, domain;
type tee_exec, exec_type, file_type;
type tee_device, dev_type;
type tee_data_file, file_type, data_file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init tee_exec:file { getattr open read execute };
allow init tee:process transition;
# New domain is entered by executing the file.
allow tee tee_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow tee init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init tee:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init tee:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init tee_exec:process tee;


type tee_tmpfs, file_type;
type_transition tee tmpfs:file tee_tmpfs;
allow tee tee_tmpfs:file { read write };


allow tee self:capability { dac_override };
allow tee tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow tee tee_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow tee tee_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow tee self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
# Any toolbox command run by init.
# At present, the only known usage is for running mkswap via fs_mgr.
# Do NOT use this domain for toolbox when run by any other domain.
type toolbox, domain;
type toolbox_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init toolbox_exec:file { getattr open read execute };
allow init toolbox:process transition;
# New domain is entered by executing the file.
allow toolbox toolbox_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow toolbox init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init toolbox:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init toolbox:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init toolbox_exec:process toolbox;


type toolbox_tmpfs, file_type;
type_transition toolbox tmpfs:file toolbox_tmpfs;
allow toolbox toolbox_tmpfs:file { read write };



# /dev/__null__ created by init prior to policy load,
# open fd inherited by fsck.
allow toolbox tmpfs:chr_file { read write ioctl };

# Inherit and use pty created by android_fork_execvp_ext().
allow toolbox devpts:chr_file { read write getattr ioctl };

# mkswap-specific.
# Read/write block devices used for swap partitions.
# Assign swap_block_device type any such partition in your
# device/<vendor>/<product>/sepolicy/file_contexts file.
allow toolbox block_device:dir search;
allow toolbox swap_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Only allow entry from init via the toolbox binary.
neverallow { domain -init } toolbox:process transition;
neverallow domain toolbox:process dyntransition;
neverallow toolbox { file_type fs_type -toolbox_exec}:file entrypoint;
# The tzdatacheck command run by init.
type tzdatacheck, domain;
type tzdatacheck_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init tzdatacheck_exec:file { getattr open read execute };
allow init tzdatacheck:process transition;
# New domain is entered by executing the file.
allow tzdatacheck tzdatacheck_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow tzdatacheck init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init tzdatacheck:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init tzdatacheck:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init tzdatacheck_exec:process tzdatacheck;


type tzdatacheck_tmpfs, file_type;
type_transition tzdatacheck tmpfs:file tzdatacheck_tmpfs;
allow tzdatacheck tzdatacheck_tmpfs:file { read write };



allow tzdatacheck zoneinfo_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow tzdatacheck zoneinfo_data_file:file unlink;
# ueventd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type ueventd, domain;

type ueventd_tmpfs, file_type;
type_transition ueventd tmpfs:file ueventd_tmpfs;
allow ueventd ueventd_tmpfs:file { read write };


# TODO: why is ueventd using __kmsg__ when it should just create
# and use /dev/kmsg instead?
type_transition ueventd device:chr_file klog_device "__kmsg__";
allow ueventd klog_device:chr_file { create open write unlink };


allow ueventd security_file:dir { open getattr read search ioctl };
allow ueventd security_file:file { getattr open read ioctl lock };

allow ueventd init:process sigchld;
allow ueventd self:capability { chown mknod net_admin setgid fsetid sys_rawio dac_override fowner };
allow ueventd device:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow ueventd device:chr_file { { getattr open read ioctl lock } { open append write } };
allow ueventd sysfs:file { { getattr open read ioctl lock } { open append write } };
allow ueventd sysfs_type:{ file lnk_file } { relabelfrom relabelto setattr getattr };
allow ueventd sysfs_type:dir { relabelfrom relabelto setattr { open getattr read search ioctl } };
allow ueventd sysfs_devices_system_cpu:file { { getattr open read ioctl lock } { open append write } };
allow ueventd tmpfs:chr_file { { getattr open read ioctl lock } { open append write } };
allow ueventd dev_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow ueventd dev_type:lnk_file { create unlink };
allow ueventd dev_type:chr_file { create setattr unlink };
allow ueventd dev_type:blk_file { create setattr unlink };
allow ueventd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow ueventd efs_file:dir search;
allow ueventd efs_file:file { getattr open read ioctl lock };

# Use setfscreatecon() to label /dev directories and files.
allow ueventd self:process setfscreate;

#####
##### neverallow rules
#####

# ueventd must never set properties, otherwise deadlocks may occur.
# https://android-review.googlesource.com/#/c/133120/6/init/devices.cpp@941
# No writing to the property socket, connecting to init, or setting properties.
neverallow ueventd property_socket:sock_file write;
neverallow ueventd init:unix_stream_socket connectto;
neverallow ueventd property_type:property_service set;
# uncrypt
type uncrypt, domain, mlstrustedsubject;
type uncrypt_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init uncrypt_exec:file { getattr open read execute };
allow init uncrypt:process transition;
# New domain is entered by executing the file.
allow uncrypt uncrypt_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow uncrypt init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init uncrypt:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init uncrypt:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init uncrypt_exec:process uncrypt;


type uncrypt_tmpfs, file_type;
type_transition uncrypt tmpfs:file uncrypt_tmpfs;
allow uncrypt uncrypt_tmpfs:file { read write };



allow uncrypt self:capability dac_override;

# Read OTA zip file from /data/data/com.google.android.gsf/app_download

allow uncrypt app_data_file:dir { open getattr read search ioctl };
allow uncrypt app_data_file:{ file lnk_file } { getattr open read ioctl lock };




# Read /cache/recovery/command
# Read /cache/recovery/uncrypt_file
# Write to pipe file /cache/recovery/uncrypt_status
allow uncrypt cache_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow uncrypt cache_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow uncrypt cache_file:fifo_file { open append write };

# Set a property to reboot the device.


allow uncrypt property_socket:sock_file write;
allow uncrypt init:unix_stream_socket connectto;

allow uncrypt powerctl_prop:property_service set;


# Raw writes to block device
allow uncrypt self:capability sys_rawio;
allow uncrypt block_device:blk_file { open append write };
auditallow uncrypt block_device:blk_file { open append write };
allow uncrypt misc_block_device:blk_file { open append write };
allow uncrypt block_device:dir { open getattr read search ioctl };

# Access userdata block device.
allow uncrypt userdata_block_device:blk_file { open append write };
###
### Untrusted apps.
###
### This file defines the rules for untrusted apps.
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###
### untrusted_app includes all the appdomain rules, plus the
### additional following rules:
###

type untrusted_app, domain;

typeattribute untrusted_app appdomain;
# Label ashmem objects with our own unique type.

type untrusted_app_tmpfs, file_type;
type_transition untrusted_app tmpfs:file untrusted_app_tmpfs;
allow untrusted_app untrusted_app_tmpfs:file { read write };

# Map with PROT_EXEC.
allow untrusted_app untrusted_app_tmpfs:file execute;


typeattribute untrusted_app netdomain;


typeattribute untrusted_app bluetoothdomain;


# Some apps ship with shared libraries and binaries that they write out
# to their sandbox directory and then execute.
allow untrusted_app app_data_file:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } execmod };

# Third party vpn apps receive an open tun fd from the framework for
# device traffic. Do not allow untrusted app to directly open tun_device
allow untrusted_app tun_device:chr_file { read write getattr ioctl append };

# ASEC
allow untrusted_app asec_apk_file:file { getattr open read ioctl lock };
# Execute libs in asec containers.
allow untrusted_app asec_public_file:file { execute execmod };

# Allow the allocation and use of ptys
# Used by: https://play.google.com/store/apps/details?id=jackpal.androidterm

# Each domain gets a unique devpts type.
type untrusted_app_devpts, fs_type;
# Label the pty with the unique type when created.
type_transition untrusted_app devpts:chr_file untrusted_app_devpts;
# Allow use of the pty after creation.
allow untrusted_app untrusted_app_devpts:chr_file { open getattr read write ioctl };
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
# allowed to everyone via domain.te.


# Used by Finsky / Android "Verify Apps" functionality when
# running "adb install foo.apk".
# TODO: Long term, we don't want apps probing into shell data files.
# Figure out a way to remove these rules.
allow untrusted_app shell_data_file:file { getattr open read ioctl lock };
allow untrusted_app shell_data_file:dir { open getattr read search ioctl };

# Read and write system app data files passed over Binder.
# Motivating case was /data/data/com.android.settings/cache/*.jpg for
# cropping or taking user photos.
allow untrusted_app system_app_data_file:file { read write getattr };

#
# Rules migrated from old app domains coalesced into untrusted_app.
# This includes what used to be media_app, shared_app, and release_app.
#

# Access /dev/mtp_usb.
# TODO android.process.media moved to priv_app domain. Does
# untrusted_app still require these permissions? Can "open"
# be removed?
allow untrusted_app mtp_device:chr_file { { getattr open read ioctl lock } { open append write } };
auditallow untrusted_app mtp_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access to /data/media.
allow untrusted_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow untrusted_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Traverse into /mnt/media_rw for bypassing FUSE daemon
# TODO: narrow this to just MediaProvider
allow untrusted_app mnt_media_rw_file:dir search;

allow untrusted_app drmserver_service:service_manager find;
allow untrusted_app mediaserver_service:service_manager find;
allow untrusted_app nfc_service:service_manager find;
allow untrusted_app radio_service:service_manager find;
allow untrusted_app surfaceflinger_service:service_manager find;
allow untrusted_app app_api_service:service_manager find;

# Allow GMS core to access perfprofd output, which is stored
# in /data/misc/perfprofd/. GMS core will need to list all
# data stored in that directory to process them one by one.


# gdbserver for ndk-gdb ptrace attaches to app process.
allow untrusted_app self:process ptrace;

# Programs routinely attempt to scan through /system, looking
# for files. Suppress the denials when they occur.
dontaudit untrusted_app exec_type:file getattr;

###
### neverallow rules
###

# Receive or send uevent messages.
neverallow untrusted_app domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow untrusted_app domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow untrusted_app debugfs:file read;

# Do not allow untrusted apps to register services.
# Only trusted components of Android should be registering
# services.
neverallow untrusted_app service_manager_type:service_manager add;

# Do not allow untrusted_apps to connect to the property service
# or set properties. b/10243159
neverallow untrusted_app property_socket:sock_file write;
neverallow untrusted_app init:unix_stream_socket connectto;
neverallow untrusted_app property_type:property_service set;

# Do not allow untrusted_app to be assigned mlstrustedsubject.
# This would undermine the per-user isolation model being
# enforced via levelFrom=user in seapp_contexts and the mls
# constraints.  As there is no direct way to specify a neverallow
# on attribute assignment, this relies on the fact that fork
# permission only makes sense within a domain (hence should
# never be granted to any other domain within mlstrustedsubject)
# and untrusted_app is allowed fork permission to itself.
neverallow untrusted_app mlstrustedsubject:process fork;

# Do not allow untrusted_app to hard link to any files.
# In particular, if untrusted_app links to other app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure untrusted_app never has this
# capability.
neverallow untrusted_app file_type:file link;

# Do not allow untrusted_app to access network MAC address file
neverallow untrusted_app sysfs_mac_address:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Do not allow untrusted app to directly open tun_device
neverallow untrusted_app tun_device:chr_file open;

# Do not allow untrusted_app access to /cache
neverallow untrusted_app cache_file:dir ~{ { open getattr read search ioctl } };
neverallow untrusted_app cache_file:file ~{ read getattr };
# Domain for update_engine daemon.
type update_engine, domain;
type update_engine_exec, exec_type, file_type;
type update_engine_data_file, file_type, data_file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init update_engine_exec:file { getattr open read execute };
allow init update_engine:process transition;
# New domain is entered by executing the file.
allow update_engine update_engine_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow update_engine init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init update_engine:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init update_engine:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init update_engine_exec:process update_engine;


type update_engine_tmpfs, file_type;
type_transition update_engine tmpfs:file update_engine_tmpfs;
allow update_engine update_engine_tmpfs:file { read write };

;

typeattribute update_engine netdomain;
;

# Following permissions are needed for update_engine.
allow update_engine self:process { setsched };
allow update_engine self:capability { fowner sys_admin };
allow update_engine kmsg_device:chr_file { open append write };

# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow update_engine sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow update_engine self:capability2 block_suspend;
;

# Allow using persistent storage in /data/misc/update_engine.
allow update_engine update_engine_data_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } };
allow update_engine update_engine_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } } };

# Allow update_engine to reach block devices in /dev/block.
allow update_engine block_device:dir search;

# Allow read/write on system and boot partitions.
allow update_engine boot_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
allow update_engine system_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Don't allow kernel module loading, just silence the logs.
dontaudit update_engine kernel:system module_request;
# vdc spawned from init for the following services:
#  defaultcrypto
#  encrypt
#
# We also transition into this domain from dumpstate, when
# collecting bug reports.

type vdc, domain;
type vdc_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init vdc_exec:file { getattr open read execute };
allow init vdc:process transition;
# New domain is entered by executing the file.
allow vdc vdc_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow vdc init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init vdc:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init vdc:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init vdc_exec:process vdc;


type vdc_tmpfs, file_type;
type_transition vdc tmpfs:file vdc_tmpfs;
allow vdc vdc_tmpfs:file { read write };






allow vdc vold_socket:sock_file write;
allow vdc vold:unix_stream_socket connectto;



# vdc sends information back to dumpstate when "adb bugreport" is used
allow vdc dumpstate:fd use;
allow vdc dumpstate:unix_stream_socket { read write getattr };

# vdc information is written to shell owned bugreport files
allow vdc shell_data_file:file { write getattr };

# Why?
allow vdc dumpstate:unix_dgram_socket { read write };
# volume manager
type vold, domain;
type vold_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init vold_exec:file { getattr open read execute };
allow init vold:process transition;
# New domain is entered by executing the file.
allow vold vold_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow vold init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init vold:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init vold:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init vold_exec:process vold;


type vold_tmpfs, file_type;
type_transition vold tmpfs:file vold_tmpfs;
allow vold vold_tmpfs:file { read write };



# Switch to more restrictive domains when executing common tools

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow vold sgdisk_exec:file { getattr open read execute };
allow vold sgdisk:process transition;
# New domain is entered by executing the file.
allow sgdisk sgdisk_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow sgdisk vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold sgdisk:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold sgdisk:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition vold sgdisk_exec:process sgdisk;
;

# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow vold sdcardd_exec:file { getattr open read execute };
allow vold sdcardd:process transition;
# New domain is entered by executing the file.
allow sdcardd sdcardd_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow sdcardd vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold sdcardd:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold sdcardd:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition vold sdcardd_exec:process sdcardd;
;

# For a handful of probing tools, we choose an even more restrictive
# domain when working with untrusted block devices

# Old domain may exec the file and transition to the new domain.
allow vold shell_exec:file { getattr open read execute };
allow vold blkid:process transition;
# New domain is entered by executing the file.
allow blkid shell_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow blkid vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold blkid:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold blkid:process { siginh rlimitinh };
;

# Old domain may exec the file and transition to the new domain.
allow vold shell_exec:file { getattr open read execute };
allow vold blkid_untrusted:process transition;
# New domain is entered by executing the file.
allow blkid_untrusted shell_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow blkid_untrusted vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold blkid_untrusted:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold blkid_untrusted:process { siginh rlimitinh };
;

# Old domain may exec the file and transition to the new domain.
allow vold fsck_exec:file { getattr open read execute };
allow vold fsck:process transition;
# New domain is entered by executing the file.
allow fsck fsck_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow fsck vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold fsck:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold fsck:process { siginh rlimitinh };
;

# Old domain may exec the file and transition to the new domain.
allow vold fsck_exec:file { getattr open read execute };
allow vold fsck_untrusted:process transition;
# New domain is entered by executing the file.
allow fsck_untrusted fsck_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow fsck_untrusted vold:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit vold fsck_untrusted:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow vold fsck_untrusted:process { siginh rlimitinh };
;

# Allow us to jump into execution domains of above tools
allow vold self:process setexec;

# For sgdisk launched through popen()
allow vold shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

typeattribute vold mlstrustedsubject;
allow vold self:process setfscreate;
allow vold system_file:file { getattr execute execute_no_trans };
# XXX Run toolbox.  Might not be needed.
allow vold toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
auditallow vold toolbox_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow vold block_device:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold device:dir write;
allow vold devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow vold rootfs:dir mounton;
allow vold sdcard_type:dir mounton; # TODO: deprecated in M
allow vold sdcard_type:filesystem { mount remount unmount }; # TODO: deprecated in M
allow vold sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } }; # TODO: deprecated in M
allow vold sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } }; # TODO: deprecated in M

# Manage locations where storage is mounted
allow vold { mnt_media_rw_file storage_file sdcard_type }:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold { mnt_media_rw_file storage_file sdcard_type }:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Access to storage that backs emulated FUSE daemons for migration optimization
allow vold media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Newly created storage dirs are always treated as mount stubs to prevent us
# from accidentally writing when the mount point isn't present.
type_transition vold storage_file:dir storage_stub_file;
type_transition vold mnt_media_rw_file:dir mnt_media_rw_stub_file;

# Allow mounting of storage devices
allow vold { mnt_media_rw_stub_file storage_stub_file }:dir { mounton create rmdir getattr setattr };
allow vold sdcard_type:filesystem { mount unmount remount };

# Manage per-user primary symlinks
allow vold mnt_user_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold mnt_user_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# Allow to create and mount expanded storage
allow vold mnt_expand_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } mounton };
allow vold apk_data_file:dir { create getattr setattr };
allow vold shell_data_file:dir { create getattr setattr };

allow vold tmpfs:filesystem { mount unmount };
allow vold tmpfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold tmpfs:dir mounton;
allow vold self:capability { net_admin dac_override mknod sys_admin chown fowner fsetid };
allow vold self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow vold app_data_file:dir search;
allow vold app_data_file:file { { getattr open read ioctl lock } { open append write } };
allow vold loop_device:blk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow vold vold_device:blk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow vold dm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow vold dm_device:blk_file { { getattr open read ioctl lock } { open append write } };
# For vold Process::killProcessesWithOpenFiles function.
allow vold domain:dir { open getattr read search ioctl };
allow vold domain:{ file lnk_file } { getattr open read ioctl lock };
allow vold domain:process { signal sigkill };
allow vold self:capability { sys_ptrace kill };

# XXX Label sysfs files with a specific type?
allow vold sysfs:file { { getattr open read ioctl lock } { open append write } };

allow vold kmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Run fsck.
allow vold fsck_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Log fsck results
allow vold fscklogs:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow vold fscklogs:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

#
# Rules to support encrypted fs support.
#

# Unmount and mount the fs.
allow vold labeledfs:filesystem { mount unmount remount };

# Access /efs/userdata_footer.
# XXX Split into a separate type?
allow vold efs_file:file { { getattr open read ioctl lock } { open append write } };

# Create and mount on /data/tmp_mnt and management of expansion mounts
allow vold system_data_file:dir { create { { open getattr read search ioctl } { open search write add_name remove_name } } mounton setattr rmdir };

# Set scheduling policy of kernel processes
allow vold kernel:process setsched;

# Property Service


allow vold property_socket:sock_file write;
allow vold init:unix_stream_socket connectto;

allow vold vold_prop:property_service set;



allow vold property_socket:sock_file write;
allow vold init:unix_stream_socket connectto;

allow vold powerctl_prop:property_service set;



allow vold property_socket:sock_file write;
allow vold init:unix_stream_socket connectto;

allow vold ctl_fuse_prop:property_service set;



allow vold property_socket:sock_file write;
allow vold init:unix_stream_socket connectto;

allow vold restorecon_prop:property_service set;


# ASEC
allow vold asec_image_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow vold asec_image_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

allow vold security_file:dir { open getattr read search ioctl };
allow vold security_file:file { getattr open read ioctl lock };

allow vold asec_apk_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } } mounton relabelfrom relabelto };
allow vold asec_public_file:dir { relabelto setattr };
allow vold asec_apk_file:file { { getattr open read ioctl lock } setattr relabelfrom relabelto };
allow vold asec_public_file:file { relabelto setattr };
# restorecon files in asec containers created on 4.2 or earlier.
allow vold unlabeled:dir { { open getattr read search ioctl } setattr relabelfrom };
allow vold unlabeled:file { { getattr open read ioctl lock } setattr relabelfrom };

# Handle wake locks (used for device encryption)

# Access /sys/power/wake_lock and /sys/power/wake_unlock
allow vold sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
# Accessing these files requires CAP_BLOCK_SUSPEND
allow vold self:capability2 block_suspend;


# talk to batteryservice

# Call the servicemanager and transfer references to it.
allow vold servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager vold:dir search;
allow servicemanager vold:file { read open };
allow servicemanager vold:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Call the server domain and optionally transfer references to it.
allow vold healthd:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow healthd vold:binder transfer;
# Receive and use open files from the server.
allow vold healthd:fd use;


# talk to keymaster
allow vold tee_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access userdata block device.
allow vold userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Access metadata block device used for encryption meta-data.
allow vold metadata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Allow vold to manipulate /data/unencrypted
allow vold unencrypted_data_file:{ file } { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
allow vold unencrypted_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };

# Write to /proc/sys/vm/drop_caches
allow vold proc_drop_caches:file { open append write };

# Give vold a place where only vold can store files; everyone else is off limits
allow vold vold_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow vold vold_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

# linux keyring configuration
allow vold init:key { write search setattr };
allow vold vold:key { write search setattr };

# vold temporarily changes its priority when running benchmarks
allow vold self:capability sys_nice;

# vold needs to chroot into app namespaces to remount when runtime permissions change
allow vold self:capability sys_chroot;
allow vold storage_file:dir mounton;

neverallow { domain -vold } vold_data_file:dir ~{ open create read getattr setattr search relabelto ioctl };
neverallow { domain -vold } vold_data_file:{ file lnk_file sock_file fifo_file } ~{ relabelto getattr };
neverallow { domain -vold -init } vold_data_file:dir *;
neverallow { domain -vold -init } vold_data_file:{ file lnk_file sock_file fifo_file } *;
neverallow { domain -vold -init } restorecon_prop:property_service set;
# watchdogd seclabel is specified in init.<board>.rc
type watchdogd, domain;
allow watchdogd watchdog_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow watchdogd kmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };
# wpa - wpa supplicant or equivalent
type wpa, domain;
type wpa_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init wpa_exec:file { getattr open read execute };
allow init wpa:process transition;
# New domain is entered by executing the file.
allow wpa wpa_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow wpa init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init wpa:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init wpa:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init wpa_exec:process wpa;


type wpa_tmpfs, file_type;
type_transition wpa tmpfs:file wpa_tmpfs;
allow wpa wpa_tmpfs:file { read write };




typeattribute wpa netdomain;


allow wpa kernel:system module_request;
allow wpa self:capability { setuid net_admin setgid net_raw };
allow wpa cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow wpa self:netlink_route_socket nlmsg_write;
allow wpa self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow wpa self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow wpa wifi_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow wpa wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };

allow wpa system_wpa_socket:sock_file write;
allow wpa system_server:unix_dgram_socket sendto;



# Call the servicemanager and transfer references to it.
allow wpa servicemanager:binder { call transfer };
# servicemanager performs getpidcon on clients.
allow servicemanager wpa:dir search;
allow servicemanager wpa:file { read open };
allow servicemanager wpa:process getattr;
# rw access to /dev/binder and /dev/ashmem is presently granted to
# all domains in domain.te.


# Create a socket for receiving info from wpa
type_transition wpa wifi_data_file:dir wpa_socket "sockets";
allow wpa wpa_socket:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow wpa wpa_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };


  allow keystore wpa:dir search;
  allow keystore wpa:file { read open };
  allow keystore wpa:process getattr;
  allow wpa keystore_service:service_manager find;
  
# Call the server domain and optionally transfer references to it.
allow wpa keystore:binder { call transfer };
# Allow the serverdomain to transfer references to the client on the reply.
allow keystore wpa:binder transfer;
# Receive and use open files from the server.
allow wpa keystore:fd use;



# WPA (wifi) has a restricted set of permissions from the default.
allow wpa keystore:keystore_key {
	get
	sign
	verify
};

# Allow wpa_cli to work. wpa_cli creates a socket in
# /data/misc/wifi/sockets which wpa supplicant communicates with.


###
### neverallow rules
###

# wpa_supplicant should not trust any data from sdcards
neverallow wpa sdcard_type:dir ~getattr;
neverallow wpa sdcard_type:file *;
# zygote
type zygote, domain;
type zygote_exec, exec_type, file_type;



# Allow the necessary permissions.

# Old domain may exec the file and transition to the new domain.
allow init zygote_exec:file { getattr open read execute };
allow init zygote:process transition;
# New domain is entered by executing the file.
allow zygote zygote_exec:file { entrypoint open read execute getattr };
# New domain can send SIGCHLD to its caller.
allow zygote init:process sigchld;
# Enable AT_SECURE, i.e. libc secure mode.
dontaudit init zygote:process noatsecure;
# XXX dontaudit candidate but requires further study.
allow init zygote:process { siginh rlimitinh };

# Make the transition occur by default.
type_transition init zygote_exec:process zygote;


type zygote_tmpfs, file_type;
type_transition zygote tmpfs:file zygote_tmpfs;
allow zygote zygote_tmpfs:file { read write };


typeattribute zygote mlstrustedsubject;
# Override DAC on files and switch uid/gid.
allow zygote self:capability { dac_override setgid setuid fowner chown };
# Drop capabilities from bounding set.
allow zygote self:capability setpcap;
# Switch SELinux context to app domains.
allow zygote self:process setcurrent;
allow zygote system_server:process dyntransition;
allow zygote appdomain:process dyntransition;
# Allow zygote to read app /proc/pid dirs (b/10455872)
allow zygote appdomain:dir { getattr search };
allow zygote appdomain:file { { getattr open read ioctl lock } };
# Move children into the peer process group.
allow zygote system_server:process { getpgid setpgid };
allow zygote appdomain:process { getpgid setpgid };
# Read system data.
allow zygote system_data_file:dir { open getattr read search ioctl };
allow zygote system_data_file:file { getattr open read ioctl lock };
# Write to /data/dalvik-cache.
allow zygote dalvikcache_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow zygote dalvikcache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Create symlinks in /data/dalvik-cache
allow zygote dalvikcache_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Write to /data/resource-cache
allow zygote resourcecache_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow zygote resourcecache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# For art.
allow zygote dalvikcache_data_file:file execute;
# Execute idmap and dex2oat within zygote's own domain.
# TODO:  Should either of these be transitioned to the same domain
# used by installd or stay in-domain for zygote?
allow zygote idmap_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow zygote dex2oat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# Control cgroups.
allow zygote cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow zygote self:capability sys_admin;
# Check validity of SELinux context before use.

allow zygote selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow zygote kernel:security check_context;

# Check SELinux permissions.

allow zygote selinuxfs:file { { getattr open read ioctl lock } { open append write } };
allow zygote kernel:security compute_av;
allow zygote self:netlink_selinux_socket *;

# Read /seapp_contexts and /data/security/seapp_contexts

allow zygote security_file:dir { open getattr read search ioctl };
allow zygote security_file:file { getattr open read ioctl lock };


# Native bridge functionality requires that zygote replaces
# /proc/cpuinfo with /system/lib/<ISA>/cpuinfo using a bind mount
allow zygote proc_cpuinfo:file mounton;

# Allow remounting rootfs as MS_SLAVE
allow zygote rootfs:dir mounton;
allow zygote sdcard_type:dir { write search setattr create add_name mounton }; # TODO: deprecated in M
dontaudit zygote self:capability fsetid; # TODO: deprecated in M
allow zygote tmpfs:dir { write create add_name setattr mounton search }; # TODO: deprecated in M
allow zygote tmpfs:filesystem { mount unmount };
allow zygote fuse:filesystem { unmount };
allow zygote labeledfs:filesystem remount; # TODO: deprecated in M

# Allowed to create user-specific storage source if started before vold
allow zygote mnt_user_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } };
allow zygote mnt_user_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock } { open append write } } };
# Allowed to mount user-specific storage into place
allow zygote storage_file:dir { search mounton };

# Handle --invoke-with command when launching Zygote with a wrapper command.
allow zygote zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

###
### neverallow rules
###

# Ensure that all types assigned to app processes are included
# in the appdomain attribute, so that all allow and neverallow rules
# written on appdomain are applied to all app processes.
# This is achieved by ensuring that it is impossible for zygote to
# setcon (dyntransition) to any types other than those associated
# with appdomain plus system_server.
neverallow zygote ~{ appdomain system_server }:process dyntransition;

# Zygote should never execute anything from /data except for /data/dalvik-cache files.
neverallow zygote {
  data_file_type
  -dalvikcache_data_file # map PROT_EXEC
}:file { execute execute_no_trans };
